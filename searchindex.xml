<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>APISIX快速入门</title><url>https://lizj3624.github.io/post/apisix-quick-start/</url><categories><category>apisix</category><category>nginx</category></categories><tags><tag>apisix</tag><tag>nginx</tag></tags><content type="html"> 前面介绍过APISIX，github开源社区比较活跃的云原生API网关， 自己根据官方的快速入门指南学习使用APISIX。
安装部署 安装部署APISIX APISIX支持rpm、docker image、helm chart、source release package安装部署，我开始开始用源码安装但是一直没有 成功，为了先开始学习，用rpm包安装的，以后再慢慢研究源码安装过程。再此提醒一下APISIX暂时不支持CentOS8，这个我 在社区提交issue，后续可能会改进。 在此我简单写一下步骤，详细安装步骤可以参考官方步骤
## apisix yum源, 会安装依赖的OpenResty(apisix-base-1.19.9.1.3-0.el7.x86_64) sudo yum-config-manager --add-repo https://repos.apiseven.com/packages/centos/apache-apisix.repo sudo yum info -y apisix sudo yum --showduplicates list apisix sudo yum install apisix 安装部署etcd apisix的数据存储在etcd中，启动apisix前需要安装etcd并启动。目前最新版本1.12版本只支持etcdv3版本。
## 安装 ETCD_VERSION='3.4.13' wget https://github.com/etcd-io/etcd/releases/download/v${ETCD_VERSION}/etcd-v${ETCD_VERSION}-linux-amd64.tar.gz tar -xvf etcd-v${ETCD_VERSION}-linux-amd64.tar.gz &amp;&amp; \ cd etcd-v${ETCD_VERSION}-linux-amd64 &amp;&amp; \ sudo cp -a etcd etcdctl /usr/bin/ ## 启动, etcd要支持数据持久化 ETCD_HOME=`pwd` sudo nohup etcd --data-dir $ETCD_HOME/data.etcd --wal-dir $ETCD_HOME/wal --snapshot-count 100000 > $ETCD_HOME/etcd.log 2>&amp;1 &amp; 启动apisix # initialize NGINX config file and etcd apisix init # generate `nginx.conf` from `config.yaml` and test it apisix test # start Apache APISIX server apisix start upstream的增删改查 详细可以查看upstream admin API
增加upstream curl "http://127.0.0.1:9080/apisix/admin/upstreams" -H "X-API-KEY: edd1c9f034335f136f87ad84b625c8f1" -X POST -d '{ "type": "roundrobin", "nodes": { "127.0.0.1:8080": 1, "127.0.0.1:8880": 1, "127.0.0.1:8881": 1 }, "retries": 2, "checks": { "active": { "timeout": 5, "http_path": "/healthcheck", "host": "lizunju.my.com", "healthy": { "interval": 2, "successes": 1 }, "unhealthy": { "interval": 1, "http_failures": 2 }, "req_headers": ["User-Agent: curl/7.29.0"] }, "passive": { "healthy": { "http_statuses": [200, 201, 302, 304], "successes": 3 }, "unhealthy": { "http_statuses": [500, 503, 504], "http_failures": 3, "tcp_failures": 3 } } } }' ## 添加成功后，返回数据中包含upstream_id(00000000000000000122)，以后可以通过这个id去关联`route`或`service` {"action":"create","node":{"key":"\/apisix\/upstreams\/00000000000000000122","value":{"retries":2,"nodes":{"127.0.0.1:8881":1,"127.0.0.1:8080":1,"127.0.0.1:8880":1},"hash_on":"vars","id":"00000000000000000122","scheme":"http","checks":{"passive":{"healthy":{"http_statuses":[200,201,302,304],"successes":3},"unhealthy":{"http_statuses":[500,503,504],"tcp_failures":3,"timeouts":7,"http_failures":3},"type":"http"},"active":{"healthy":{"http_statuses":[200,302],"interval":2,"successes":1},"timeout":5,"req_headers":["User-Agent: curl\/7.29.0"],"unhealthy":{"http_failures":2,"tcp_failures":2,"timeouts":3,"interval":1,"http_statuses":[429,404,500,501,502,503,504,505]},"host":"lizunju.my.com","concurrency":10,"http_path":"\/healthcheck","https_verify_certificate":true,"type":"http"}},"pass_host":"pass","update_time":1647059500,"type":"roundrobin","create_time":1647059500}}} 这个upstream还支持主动/被动健康检查，apisix健康检查只有有请求转发到这个upstream时才启动。 有admin API请求时，必须每次都得加token(&lsquo;X-API-KEY: edd1c9f034335f136f87ad84b625c8f1&rsquo;)，不然API校验不通过。
修改upstream # 修改时，可以通过PUT方法 curl "http://127.0.0.1:9080/apisix/admin/upstreams/1" -H "X-API-KEY: edd1c9f034335f136f87ad84b625c8f1" -X PUT -d ' { "type": "roundrobin", "nodes": { "httpbin.org:80": 1 } }' 查询 curl http://127.0.0.1:9080/apisix/admin/upstreams/00000000000000000122 -H 'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1' {"node":{"key":"\/apisix\/upstreams\/00000000000000000122","value":{"retries":2,"nodes":{"127.0.0.1:8881":1,"127.0.0.1:8080":1,"127.0.0.1:8880":1},"hash_on":"vars","create_time":1647059500,"type":"roundrobin","pass_host":"pass","checks":{"passive":{"healthy":{"http_statuses":[200,201,302,304],"successes":3},"unhealthy":{"http_statuses":[500,503,504],"tcp_failures":3,"timeouts":7,"http_failures":3},"type":"http"},"active":{"healthy":{"http_statuses":[200,302],"successes":1,"interval":2},"timeout":5,"req_headers":["User-Agent: curl\/7.29.0"],"unhealthy":{"http_failures":2,"tcp_failures":2,"timeouts":3,"interval":1,"http_statuses":[429,404,500,501,502,503,504,505]},"host":"lizunju.my.com","concurrency":10,"http_path":"\/healthcheck","https_verify_certificate":true,"type":"http"}},"update_time":1647059500,"scheme":"http","id":"00000000000000000122"}},"action":"get","count":1} route的增删改查 route admin API
新增route curl "http://127.0.0.1:9080/apisix/admin/routes" -H "X-API-KEY: edd1c9f034335f136f87ad84b625c8f1" -X POST -d '{ "methods": ["GET"], "host": "test.my.com", "uri": "/", "upstream_id": "00000000000000000122" }' ## 返回数据中也是包含route_id，00000000000000000212 {"action":"create","node":{"key":"\/apisix\/routes\/00000000000000000212","value":{"methods":["GET"],"upstream_id":"00000000000000000122","uri":"\/","host":"test.my.com","id":"00000000000000000212","status":1,"update_time":1647064681,"priority":0,"create_time":1647064681}}} route的规则是GET方法、host，uri
upstream_id就是上面创建upstream的id，这样命中这个route的请求就会转发到这个upstream上，route也是直接添加upstream， 但是route跟upstream是1:N得关系，为了重复添加重复的upstream，推荐用upstream_id的方式与route绑定；route也是支持service的， 如果service和(upstream或upstream_id)并存时，upstream优先。
修改route curl "http://127.0.0.1:9080/apisix/admin/routes/00000000000000000212" -H "X-API-KEY: edd1c9f034335f136f87ad84b625c8f1" -X PUT -d '{ "methods": ["GET"], "host": "test.my.com", "uri": "/mypath", "upstream_id": "00000000000000000122" }' 删除route curl http://127.0.0.1:9080/apisix/admin/routes/00000000000000000212 -H 'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1' -X DELETE 测试验证 curl http://127.0.0.1:9080/ -H "Host: test.my.com"</content></entry><entry><title>区块链技术快速入门</title><url>https://lizj3624.github.io/post/learn-block-chain/</url><categories><category>区块链</category><category>blockchain</category></categories><tags><tag>区块链</tag><tag>blockchain</tag></tags><content type="html"> 知乎一网友写快速学习区块链技术的文章，从读书学习构建区块链技术体系，然后去实践，我感觉非常不错，再次收藏一下。 对格式、文章结构、部分引用url略有改动，原文
2019年从互联网后端开发工程师转型为区块链工程师。一个月时间系统学习区块链技术，参与到链研发工作当中。下面来谈谈自己的学习心得，希望能够帮助到你。
关于「如何高效的自学一项新技能」，我通常分为两步走：
搜集高质量学习材料和工具。 应用合适的学习方法。 区块链经过18、19年的火热发展后，网络上大家都能轻易的找到各种各样的高质量学习资料。此外，本问题的大部分答案都是围绕「学习什么」，因此，下文我将重点介绍「如何学习」的方法论。
一、泛读通读，建立框架，「不求甚解」 尽管区块链和其他的计算机技术没有本质上的区别，但有一个很重要的差异是，区块链技术涉及的技术面非常广。事实上，当我们把中本聪的区块链技术拆解后可发现，区块链技术是由20世纪提出的一些老技术和知识的组合而成的，换句话说，区块链的创新在于老技术的组合创新，正正体现了区块链技术的系统之美。也正是如此，区块链技术涉及知识面非常广，其中包括：分布式系统、拜占庭问题、密码学、数据结构、P2P网络等技术，以及博弈论、经济学等思想。
如果你一开始就针对某一方面孤立学习，不但无法系统化的学习，并且容易迷失在繁多复杂的新概念当中。因此，我建议的方法：以泛读通读的方式，先建立知识框架，对区块链有个大致的认识。
区块链是伴随比特币而产生的，因此要搞明白区块链，首先需要了解比特币：
普林斯顿大学课程 Bitcoin and Cryptocurrency Technologies 《精通比特币》 比特币白皮书 除此之外，对区块链技术的演变也要有一定的了解。作为区块链2.0的代表的以太坊是同样值得学习：
以太坊白皮书 以太坊开发入门指南 精通以太坊（中文版） 《区块链技术指南》 记住！你不需要一字一句全部读完，遇到不懂的概念和知识点记录下来和忽略。在这个过程中，配合搜索引擎，你需要不断的去思考和回答以下几个问题：
区块链、比特币和以太坊是什么？它们的工作原理大概是如何的？比特币和以太坊的区别？ 它们具备什么性质？包含哪些关键的技术点？ 区块链的发明目的是解决什么问题？除此以外，还能解决什么问题？ 区块链具备什么优缺点？ 完成这一步后，你已经对区块链和比特币有一个相对宏观、整体的认识，并初步建立了一个属于你自己的知识框架，此框架在后面的学习中会起到重要的作用。 也许你会觉得你建立的框架并不正确和完整，但不要紧，随着你的认识加深，不断的修正和完善框架。学习本身就是一个螺旋式上升的过程。
二、从外到内，逐一突破 建立知识框架之后，下一步你需要做的就是丰富和完善它。对于第一步中遗留的那些「似懂非懂」的概念和知识点，便可以在这个环节中逐一突破。
简单来说，你要做的便是：主动学习——快速定位你存在疑惑的概念和知识点，用一切办法来攻克它。
在这个阶段中， 除了回顾上面推荐的材料以外， 你需要广泛的搜索，不局限任何的形式。高质量的搜索结果依赖于准确的问题定义， 因此在查询过程中也逐渐帮助定义清楚你的疑惑。此外推荐两个关于区块链技术的中文社区：
深入浅出区块链 比特币布道者 当你在攻克某一个知识点和概念的过程中，你一定会遇到其他新的知识点，此时你便可以顺藤摸瓜，把相关的知识一并学习吸收。 值得注意的是，在这个过程中需要把握好知识扩展的度，避免过度分散注意力，重点还是关注原来的疑惑本身，以目标为导向。至于如何把握，我的建议是：
判断新遇到的概念是否直接影响到你理解原来的概念？若是，务必一切办法攻克它； 新概念在整个框架（知识体系）中是否占有很重要的地位？还是说只是某个知识点延伸出来的小分支？ 比如：在你了解P2P网络时遇到新概念分布式哈希表（DHT），此概念只不过是P2P网络中用于定位特定节点或数据的一个技术手段，显然可暂时不需要深入了解； 要理解新知识点的要求是否远超过当前的知识储备？若是，你也可以暂且先放一放，如：EVM原理。 重点关注的范围还是围绕区块链的工作原理相关的概念为主，如：1）如何处理交易和记账；2）如何产生区块及达成共识；如何验证和储存状态等过程中的重要概念。此外，不必过分追求技术的实现细节。
而关于如何判断是否真正理解透彻，我建议使用「费曼方法， 尝试用自己的方式，用通熟易懂的语言描述清楚。当解决完成相关的概念后，把它们重新放在框架里，不断修正和完善框架。
完成这一步后，我相信你已经对区块链及两个应用的大部分重要概念都理解通透了，基本概念如：
去中心化 共识机制 工作量证明PoW、PoS 非对称加密 硬（软）分叉 双花 智能合约 Merkle Tree(默克尔树) 51%攻击 三、从点到面，构建知识网络 进入第三部以后，你的区块链技术算是入门了。基于你所建立的框架，你已经有能力去理解之前晦涩难懂的概念。接下来，你便可以进一步扩大区块链技术的广度和深度，如：
其他的区块链项目，如：Filecoin、Fabric、EOS等 不同类型的共识算法 零知识证明 区块链的可扩展性方案 智能合约的编写 …… 当你学习上述新的知识的过程中，你需要刻意的去思考和构建知识间的「联系」——此知识和别的知识有什么关系？是如何关联一起的？
知识的本质永远不是信息本身，而是信息之间的联系。正是这种联系，涌现出了超越单个信息点总和的「系统性」。
而区块链技术的创新本身也恰恰是「系统性」。 在这个过程中，我主要的使用如下的系统性方法
对比 将解决同一个问题的不同技术手段归纳整理在一起，多维度进行对比，找出共性和异性。比如：PoW与PoS之间的区别？
PoW vs PoS
分类 目前解决区块链的可行性方案有哪些潜在的研发方向？具体有哪些技术手段？
区块链技术可扩展方案
提炼 尝试用最精炼的语言貌似一类相关的知识点，比如比特币的核心原理：
中本聪使用非对称加密解决电子货币的所有权问题； 用区块时间戳解决交易的存在性问题； 用分布式账本解决剔除第三方机构后交易的验证问题； 用工作量证明和最长链约定来保证节点状态的一致性，已解决「双花」问题。 架构 尝试对系统中的关键模块和模块间的关系进行抽象，并绘制成架构图，如：区块链的分层架构。
区块链分层架构
流程 也可以将根据信息流将不同的知识点串联在一起，绘制成流程图。如：以太坊交易打包流程。
以太坊交易打包流程，来源：CSDN
总之，你需要想尽一些的办法，将知识点关联在一起，逐渐结构化、系统化。
四、实践是检验真理的唯一标准 到这一步后，你掌握的区块链技术的知识体系逐步成型，接下来需要做的便是将技术落地到应用中。
首先，尝试在本地搭建比特币、以太坊的测试网络，和做不同类型的交易交易。对于以太坊，你还可以部署和调用智能合约等等。
以太坊本地私有链开发环境搭建 开始编写更加复杂的Dapp应用：
Solidity语言文档 Web3.JS接口文档 Truffle框架文档 Open Zeppelin框架文档 Ethereum Smart Contract Security Best Practices Ethereum Voting Dapp React Ethereum Dapp Example 在此环节，你的主要目标是熟悉并掌握开发Dapp的相关技能和工具。
五、Code As Documentation 最后一步，选择一个你感兴趣的项目，阅读它的源码，了解底层技术的实现原理，将理论与实践进一步融会贯通。 关于项目的选择，我个人建议是以太坊，至今为止，以太坊的应用面还是最广的，受到各大互联网公司的青睐。
至于如何阅读和学习以太坊的源码，个人建议结合以太坊的黄皮书对比阅读学习。可参考：
以太坊黄皮书-中文版 以太坊代码剖析 解读以太坊黄皮书 以太坊源代码分析 Go Ethereum Code Analysis 七、最后的最后 区块链行业真处于高速发展的时候，作为区块链从业人员，不仅仅要掌握技术，还需要时刻掌握行业动态，挖掘其他有价值的项目，把握认知变现的机会。
《区块链革命》 《货币的非国家化》 希望以上答案可以对你有所帮助！</content></entry><entry><title>Grab 2021Q4以及全年财报</title><url>https://lizj3624.github.io/post/grab-2021/</url><categories><category>grab</category><category>财报</category></categories><tags><tag>grab</tag><tag>财报</tag></tags><content type="html"> Grab是东南亚领先的超级APP，在食品配送、移动出行、金融服务的电子钱包方面是东南亚的领导者。 Grab在东南亚地区八个国家（柬埔寨、印度尼西亚、马来西亚、缅甸、菲律宾、新加坡、泰国和越南）的480个城市的交付、移动和数字金融服务领域开展业务。
Grab 2021全年财务亮点： GMV同比增长29%，至161亿美元。
2021年MTU(月交易用户)为2410w，2021年12份MTU为2770，每位用户的平均支出(定义MTU的GMV)同步增长31%至666美元。
配送和金融服务的GMV增长56%，Pre-Interco TPV同比增长37%。配送和金融服务，收入同比增长44%至6.75亿。 Grab报告的收入不包括消费者、商家和司机合作伙伴的激励措施。
2021年全年亏损36亿美元，其中包含与Grab公开上市后停止的可转换可赎回优先股相关的16亿美元非现金利息费用和3.53亿美元的一次性公开上市相关费用。
调整后的EBITDA为(8.42)亿美元，符合我们的指导范围。同比下降8%。然而，与2020年的 (6.2)% 相比，占GMV(5.2)%的调整后EBITDA利润率有所改善。
截至第四季度末，现金流动性总计90亿美元，而我们的净现金流动性为68亿美元。
Grab 2021年Q4财务亮点： GMV同比增长26%，达到45亿美元，交付和金融服务表现出强劲的同比GMV和TPV（Pre-interco）分别增长52%和29%。出行GMV同比下降11%，但继续复苏，环比增长45%。
MTU(月交易用户)同比增长3%和环比增长18%，达到2600万。每位用户的平均支出同比增长23%至173美元。
收入为1.22亿美元，同比下降44%，原因是Grab抢先投资以增加司机供应，以支持出行需求的强劲复苏。随着Grab对其类别份额和MTU增长的投资，消费者对移动性和交付的激励也增加了。
该期间的亏损为11亿美元，其中包括与Grab公开上市后停止的可转换可赎回优先股相关的3.11亿美元非现金利息费用和与一次性公开上市相关费用相关的3.28亿美元，其中2.9亿美元为非现金.
调整后的EBITDA为(3.05)亿美元，同比下降2.03亿美元。调整后EBITDA利润率为GMV的 (6.8)%，而2020年第四季度为(2.8)%。 下降的原因是上述激励措施投资增加，以及对技术和金融服务等领域的战略投资，包括数字银行我们准备在新加坡推出它。
Grab各业务线财务亮点 配送 2021年GMV为85亿美元，同比增长56%；Q4 GMV同比增长52%至24亿美元
2021年配送佣金为18.2%，高于2020的16.6%。
2021年收入为1.48亿美元，高于2020的500万美元；Q4收入下降98%至100万美元，原因是 Grab 投资了激励措施以保持其类别领导地位并增加对新服务的采用。
2021年调整后EBITDA亏损1.30亿美元，占GMV的百分比为1.5%，比2020年的3.9%有所改善。第四季度交付部门调整后EBITDA亏损84万美元。
移动出行 2021年的GMV为28亿美元，同比下降14%; Q4 GMV环比增长45%（同比下降 11%）至7.65亿美元。
2021年的出行佣金率为23.4%，高于2020年的21.3%。
2021年的收入同比增长4%至4.56亿美元。Q4收入为1.05亿美元，同比下降27%，原因是Grab投资于司机激励措施以加强司机供应以实现强劲复苏。
2021年部门调整后EBITDA为3.45亿美元，与2021年的GMV相比，利润率为12.4%，高于2020年的9.5%。Q4调整后EBITDA为7600万美元，与2020年第四季度相比下降32%。
金融服务 2021年的总支付额（InterCo 之前）为121亿美元，同比增长37%。第四季度InterCo前的TPV同比增长29%至34亿美元。
2021年的佣金率为2.3%，高于2020年的1.9%。
2021年的收入同比增长3700万美元，同期2700万美元。第四季度金融服务亏损100万美元，同比增长300万美元。
&ldquo;花呗"的TPV增长了5倍。
企业以及创新服务 GMV同比增长248%至1.53亿美元。Q4 GMV同比增长127%至5100万美元。Grab的广告GMV Q4同比增长189%。
收入同比增长22%至4400万美元。Q4同比下降39%至1600万美元。
EBITDA为930万美元，占GMV的6%，而2020年为21%；Q4 EBITDA为500万美元，同比下降1500万美元。
配送业务全年GMV占比53%，收入占比22%，由于奖励机制Q4收入大幅下降。 移动出行全年GMV占17%，收入占比67%，是Grab收入的重要来源，但是年GMV同比下降14%，年收入同比只有4%的增长，由于奖励机制Q4收入同比降低27%。 导致Q4整体收入下降44%，导致财报后股价暴跌。Q4收入进行奖励机制后效果是Q4 GMV同比增长26%，月交易用户同比增加3%，环比增加18%，到2600w。
2022年Q1展望： 配送GMV将在24亿至25亿美元之间。
移动出行GMV将在7.5亿美元至8亿美元之间。
金融服务Pre-InterCo TPV将在31亿至32亿美元之间。
展望2022年以后，Grab将在2023年上半年实现核心食品配送部门调整后EBITDA盈亏平衡，并在2023年底实现交付部门调整后EBITDA盈亏平衡， 从长远来看，Grab的目标是：移动出行调整后EBITDA占GMV的12%，配送为3%。</content></entry><entry><title>云原生API网关APISIX简介</title><url>https://lizj3624.github.io/post/apisix-primer/</url><categories><category>apisix</category><category>cloudnative</category></categories><tags><tag>apisix</tag><tag>cloudnative</tag></tags><content type="html"> 缘起 APISIX是国内在github开源社区比较活跃的云原生API网关，目前(2022-03-06)github star 8.6k，fork 1.6k。APISIX底层是基于Nginx和OpenResty， 我本人在工作中也是经常用到Nginx和OpenResty，因此对这个项目比较感兴趣，最近开始研究它，先了解它的架构以及一些概念。
架构 APISIX最底层是基于Nginx，再上一次层是OpenResty，再上一次层是ngx_lua开发的APISIX core，再上一层是APISIX Plugin Runtime(插件运行时)， 最上层是APISIX的插件，它还支持多语言(go, java等)的插件。 插件化是APISIX架构设计很不错的地方，可以使APISIX易扩展，集成了大量丰富的插件，通过rpc的方式支持多语言插件。插件请求的很多阶段被调用。 一些概念 Route路由 route路由是请求进入APISIX后，根据一定匹配规则，将请求流量转发到指定upstream或者service。
如果router配置upstream和service时，优先使用upstream 路由包含三部分：
匹配规则(比如: uri, host, remote_addr) 插件匹配(比如: 限流插件) upstream上游信息 Plugin插件 Plugin是请求/响应过程中执行的插件配置。Plugin配置可直接绑定在Route上，也可以被绑定在Service或Consumer上。 而对于同一个插件的配置，只能有一份是有效的，配置选择优先级总是Consumer > Route > Service。 一个插件在一次请求中只会执行一次，即使被同时绑定到多个不同对象中（比如Route或Service）
Service服务 Service是某类服务的抽象，是有Plugin和upstream组成的一组服务，Plugin可以选的，它通常与上游upstream服务抽象是一一对应的。 Route与Service之间，通常是N:1的关系。
Consumer消费者 Consumer是某类服务的消费者，需与用户认证体系配合才能使用。 比如不同的Consumer请求同一个API， 网关服务根据当前请求用户信息，对应不同的Plugin或Upstream配置。
Upstream上游 Upstream是虚拟主机抽象，对给定的多个服务节点按照配置规则进行负载均衡。Upstream的地址信息可以直接配置到Route(或Service) 上， 当Upstream有重复时，就需要用“引用”方式避免重复了。</content></entry><entry><title>独立开发者</title><url>https://lizj3624.github.io/post/developer/</url><categories><category>独立开发者</category></categories><tags><tag>独立开发者</tag></tags><content type="html"> 中国独立开发者列表 创造者日报 独立开发者社区</content></entry><entry><title>Cpu排名</title><url>https://lizj3624.github.io/post/cpu-rank/</url><categories/><tags><tag>cpu</tag></tags><content type="html"> 手机CPU性能天梯图 桌面CPU性能天梯图 移动端CPU综合性能排行</content></entry><entry><title>lua-nginx-module模块源码浅析</title><url>https://lizj3624.github.io/post/lua-nginx-module-arch/</url><categories><category>nginx源码分析</category></categories><tags><tag>nginx源码分析</tag><tag>lua-nginx</tag></tags><content type="html"> 最近在公司接入层的nginx支持QUIC+HTTP3的工作，我们的nginx用了lua-nginx-module模块，在启用HTTP3时，这个模块偶发epoll_ctl(1, 3) failed (17: File exists)的错误， 感觉应该是lua-nginx-module对HTTP3支持不好，因此看一下源码，适配一下HTTP3。
架构 学习lua-nginx-module模块前，先了解这个模块指令在nginx处理阶段的执行调用的情况，再次借用一下官方的图。 //master进程初始化时调用 init_by_lua* //worker进程初始化时调用 init_worker_by_lua* //ssl握手阶段调用 ssl_certificate_by_lua* set_by_lua* //rewrite阶段调用 rewrite_by_lua* //access阶段调用, 指令运行于nginx access阶段的末尾，因此总是在allow和deny这样的指令之后运行 access_by_lua* //content阶段调用, 所有请求处理阶段中最为重要的一个，运行在这个阶段的配置指令一般都肩负着生成内容（content）并输出HTTP响应 content_by_lua* //设置upstream阶段调用 balancer_by_lua* //过滤header头, 一般只用于设置Cookie和Headers等 header_filter_by_lua* //过滤body, 一般会在一次请求中被调用多次, 因为这是实现基于HTTP1.1 chunked 编码的所谓“流式输出”的 body_filter_by_lua* //日志阶段 log_by_lua* 模块初始化 lua-nginx-module也是nginx的第三方模块，它也遵守nginx模块开发规范，可以查看nginx模块化架构了解nginx的模块化开发，nginx加载lua指令时会有初始化。 先看一下这个模块的定义: ngx_module_t ngx_http_lua_module = { NGX_MODULE_V1, &amp;ngx_http_lua_module_ctx, /* module context */ ngx_http_lua_cmds, /* module directives */ NGX_HTTP_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ ngx_http_lua_init_worker, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING }; lua模块的init_process回调函数
ngx_int_t ngx_http_lua_init_worker(ngx_cycle_t *cycle) { //获取lua模块的配置信息 lmcf = ngx_http_cycle_get_module_main_conf(cycle, ngx_http_lua_module); ... http_ctx ... //模块create_srv_conf，merge_srv_conf，create_loc_conf，merge_loc_conf ... ctx = ngx_http_lua_create_ctx(r); ... //http request放到lua中 ngx_http_lua_set_req(lmcf->lua, r); //init_worker_by的post回调函数 (void) lmcf->init_worker_handler(cycle->log, lmcf, lmcf->lua); ... } ngx_conf_parse====>ngx_conf_handler====&raquo;ngx_http_block====>postconfiguration
lua模块的postconfiguration回调函数，初始化lua vm
static ngx_int_t ngx_http_lua_init(ngx_conf_t *cf) { ... lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module); ... //设置ngx http处理阶段的回调函数 cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); if (lmcf->requires_rewrite) { h = ngx_array_push(&amp;cmcf->phases[NGX_HTTP_REWRITE_PHASE].handlers); if (h == NULL) { return NGX_ERROR; } *h = ngx_http_lua_rewrite_handler; } if (lmcf->requires_access) { h = ngx_array_push(&amp;cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers); if (h == NULL) { return NGX_ERROR; } *h = ngx_http_lua_access_handler; } dd("requires log: %d", (int) lmcf->requires_log); if (lmcf->requires_log) { arr = &amp;cmcf->phases[NGX_HTTP_LOG_PHASE].handlers; h = ngx_array_push(arr); if (h == NULL) { return NGX_ERROR; } if (arr->nelts > 1) { h = arr->elts; ngx_memmove(&amp;h[1], h, (arr->nelts - 1) * sizeof(ngx_http_handler_pt)); } *h = ngx_http_lua_log_handler; } if (multi_http_blocks || lmcf->requires_header_filter) { rc = ngx_http_lua_header_filter_init(); if (rc != NGX_OK) { return rc; } } if (multi_http_blocks || lmcf->requires_body_filter) { rc = ngx_http_lua_body_filter_init(); if (rc != NGX_OK) { return rc; } } ... //如果lua环境不存在，初始化 if (lmcf->lua == NULL) { lmcf->lua = ngx_http_lua_init_vm(NULL, cf->cycle, cf->pool, lmcf, cf->log, NULL); ... //init_by_lua的post回调函数ngx_http_lua_init_by_file rc = lmcf->init_handler(cf->log, lmcf, lmcf->lua); ... } } lua-nginx-module这个模块赋予了nginx支持lua的能力，这个模块在nginx启动时初始化lua的执行环境。 为worker初始化lua vm函数，lua_State
static lua_State * ngx_http_lua_new_state(lua_State *parent_vm, ngx_cycle_t *cycle, ngx_http_lua_main_conf_t *lmcf, ngx_log_t *log) { ... L = luaL_newstate(); ... ngx_http_lua_init_registry(L, log); ngx_http_lua_init_globals(L, cycle, lmcf, log); return L; } 模块指令的执行过程 以access_by_lua*这类指令执行的过程，看一下指令的指令流程, 先看一下指令的定义
{ ngx_string("access_by_lua_file"), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF |NGX_CONF_TAKE1, ngx_http_lua_access_by_lua, NGX_HTTP_LOC_CONF_OFFSET, 0, (void *) ngx_http_lua_access_handler_file }, 指令的set函数ngx_http_lua_access_by_lua, post函数是ngx_http_lua_access_handler_file
char * ngx_http_lua_access_by_lua(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) { //加载lua文件 //设置access_handler回调, post函数(ngx_http_lua_access_handler_file) llcf->access_handler = (ngx_http_handler_pt) cmd->post; } ngx_int_t ngx_http_lua_access_handler_file(ngx_http_request_t *r) { ... //获取lua vm L = ngx_http_lua_get_lua_vm(r, NULL); //加载lua到cache中 /* load Lua script file (w/ cache) sp = 1 */ rc = ngx_http_lua_cache_loadfile(r->connection->log, L, script_path, llcf->access_src_key); ... return ngx_http_lua_access_by_chunk(L, r); } static ngx_int_t ngx_http_lua_access_by_chunk(lua_State *L, ngx_http_request_t *r) { //开启lua协程,为每个请求分配一个协程 co = ngx_http_lua_new_thread(r, L, &amp;co_ref); ... //将request请求与协程绑定 ngx_http_lua_set_req(co, r); ... //执行协程 rc = ngx_http_lua_run_thread(L, r, ctx, 0); if (rc == NGX_AGAIN) { //协程处理 rc = ngx_http_lua_run_posted_threads(c, L, r, ctx, nreqs); if (rc == NGX_ERROR || rc == NGX_DONE || rc > NGX_OK) { return rc; } if (rc != NGX_OK) { return NGX_DECLINED; } } else if (rc == NGX_DONE) { //释放协程 ngx_http_lua_finalize_request(r, NGX_DONE); rc = ngx_http_lua_run_posted_threads(c, L, r, ctx, nreqs); if (rc == NGX_ERROR || rc == NGX_DONE || rc > NGX_OK) { return rc; } if (rc != NGX_OK) { return NGX_DECLINED; } } ... } 总结 从源码大致看一下lua-nginx-module的执行过程，lua vm初始化部分还有一些疑惑，后期再细细看看。</content></entry><entry><title>nginx源码分析-模块化架构</title><url>https://lizj3624.github.io/post/ngx-module-arch/</url><categories><category>nginx源码分析</category></categories><tags><tag>nginx源码分析</tag><tag>nginx</tag></tags><content type="html"> 从源码角度分析一下nginx的模块化设计架构，主要通过nginx-1.15.8源码以及陶辉写的《深入理解Nginx模块开发与架构解析》进行分析的。
nginx模块的数据结构 nginx模块化的设计主要体现在ngx_module_t的数据结构 struct ngx_module_s { ngx_uint_t ctx_index; ngx_uint_t index; char *name; ngx_uint_t spare0; ngx_uint_t spare1; ngx_uint_t version; const char *signature; void *ctx; ngx_command_t *commands; ngx_uint_t type; ngx_int_t (*init_master)(ngx_log_t *log); ngx_int_t (*init_module)(ngx_cycle_t *cycle); ngx_int_t (*init_process)(ngx_cycle_t *cycle); ngx_int_t (*init_thread)(ngx_cycle_t *cycle); void (*exit_thread)(ngx_cycle_t *cycle); void (*exit_process)(ngx_cycle_t *cycle); void (*exit_master)(ngx_cycle_t *cycle); uintptr_t spare_hook0; uintptr_t spare_hook1; uintptr_t spare_hook2; uintptr_t spare_hook3; uintptr_t spare_hook4; uintptr_t spare_hook5; uintptr_t spare_hook6; uintptr_t spare_hook7; }; typedef struct ngx_module_s ngx_module_t; 主要字段说明 ctx_index表示当前模块在这类(type类型)模块中的序号。它非常重要，Nginx的模块化设计非常依赖于各个模块的顺序，它们即用于表达优先级，也用于表明每个模块的位置，以便nginx框架快速获得某个模块的数据。
ctx_index赋值主要在ngx_count_modules函数处理的。
index表示当前模块在nginx所有模块ngx_modules中的序号，nginx在启动时会根据ngx_modules数组设置各个模块的index值
ngx_int_t ngx_preinit_modules(void) { ngx_uint_t i; for (i = 0; ngx_modules[i]; i++) { ngx_modules[i]->index = i; ngx_modules[i]->name = ngx_module_names[i]; } ngx_modules_n = i; ngx_max_module = ngx_modules_n + NGX_MAX_DYNAMIC_MODULES; return NGX_OK; } ctx ctx用于指向一类模块的上下文结构体，指向这类特定模块的公共接口，只对HTTP模块，主要ngx_http_module_t结构体，后面会介绍这个结构体
commands 模块所支持的指令。
type 模块的类型, 与ctx密切相关，主要有这种类型NGX_HTTP_MODULE、NGX_CORE_MODULE、NGX_CONF_MODULE、NGX_EVENT_MODULE、NGX_MAIL_MODULE、NGX_STREAM_MODULE
init_master 代码中好像没有调用，貌似做保留用，从字面上来，应该是master进程启动时调用。
init_module 每个模块如果设置这个回调函数，初始化时调用。
ngx_int_t ngx_init_modules(ngx_cycle_t *cycle) { ngx_uint_t i; for (i = 0; cycle->modules[i]; i++) { if (cycle->modules[i]->init_module) { if (cycle->modules[i]->init_module(cycle) != NGX_OK) { return NGX_ERROR; } } } return NGX_OK; } ngx_init_modules函数主要是由master进程fork子进程前的ngx_init_cycle调用
init_process 子进程for完成后调用。主要由ngx_worker_process_init调用，而ngx_worker_process_init主要有fork子进程后的ngx_worker_process_cycle调用。
ngx_master_process_cycle&ndash;>ngx_start_worker_processes&ndash;>ngx_worker_process_cycle&ndash;>ngx_worker_process_init&ndash;>cycle->modules[i]->init_process(cycle)
init_thread 多线程模式下调用，nginx已经支持多线程模式，但是再这里暂不讨论。
exit_thread 多线程模式下调用，nginx已经支持多线程模式，但是再这里暂不讨论。
exit_process woker子进程时调用。
exit_master master进程时调用。
模块的数据结构中的初始化回调函数init_module、init_process、exit_process、exit_master是由nginx框架调用的，跟HTTP框架无关，因此HTTP模块时可以设置为NULL，HTTP模块主要设置ctx和commands, 针对HTTP模块来说，ctx指向ngx_http_moduel_t的数据结构，commands被赋值于ngx_command_t的结构体。我们通过lua-nginx-module的模块代码。
ngx_module_t ngx_http_lua_module = { NGX_MODULE_V1, // ngx_module_t数据结构的前7个字段，通过一个宏定义统一赋值 &amp;ngx_http_lua_module_ctx, /* module context */ //ctx字段, 主要是ngx_http_module_t指针 ngx_http_lua_cmds, /* module directives */ //commands字段, 只要是ngx_command_t结构体 NGX_HTTP_MODULE, /* module type */ //type字段 NULL, /* init master */ //init_master回调函数 NULL, /* init module */ //init_module回调函数 ngx_http_lua_init_worker, /* init process */ //init_process回调函数 NULL, /* init thread */ //init_thread回调函数 NULL, /* exit thread */ //exit_thread回调函数 NULL, /* exit process */ //exit_process回调函数 NULL, /* exit master */ //exit_master回调函数 NGX_MODULE_V1_PADDING //其他字段剩余字段统一宏定义赋值 }; ctx的数据结构在ngx_module_t中是void类型，可以是任何指针类型，在HTTP模块主要是ngx_http_module_t的数据结构指针，其他模块可能是其他类型，我们先从HTTP模块分析
HTTP模块的ctx数据结构 HTTP模块的ctx主要是ngx_http_module_t的结构体指针，我们来看一下这个结构体
typedef struct { ngx_int_t (*preconfiguration)(ngx_conf_t *cf); //解析配置前调用 ngx_int_t (*postconfiguration)(ngx_conf_t *cf); //完成配置解析后调用 void *(*create_main_conf)(ngx_conf_t *cf); //main级别(http{}块配置项)中的全局配置时，回调函数创建存储全局配置的结构体 char *(*init_main_conf)(ngx_conf_t *cf, void *conf); //main级别配置项的初始化 void *(*create_srv_conf)(ngx_conf_t *cf); //srv级别(server{}块)的配置时，回调函数创建存储配置的结构体 char *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf); //srv级别初始化回调函数 void *(*create_loc_conf)(ngx_conf_t *cf); //loc级别(location{})的配置时，回调函数创建存储配置的结构体 char *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf); //用于合并srv级别和loc级别同名配置项 } ngx_http_module_t; 这8个回调函数在HTTP模块的调用顺序可能跟定义顺序不一致，实际顺序应该如下：
create_main_conf
create_srv_conf
creat_loc_conf
preconfiguration
init_main_conf
init_srv_conf
init_loc_conf
postconfiguration
这8个函数都在ngx_http_block函数中调用
static char * ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) { ... //初始化ngx_http_conf_ctx_t的ctx，ctx->main_conf，ctx->srv_conf，ctx->loc_conf //调用逐个Http模块的create_main_conf，create_srv_conf，create_loc_conf //调用preconfiguration //调用http{}块的配置 rv = ngx_conf_parse(cf, NULL); //调用各个模块的init_main_conf，init_srv_conf，init_loc_conf //调用各个模块的postconfiguration ... } 我们来看一下lua-nginx-module的ngx_http_module_t
ngx_http_module_t ngx_http_lua_module_ctx = { NULL, /* preconfiguration */ ngx_http_lua_init, /* postconfiguration */ ngx_http_lua_create_main_conf, /* create main configuration */ ngx_http_lua_init_main_conf, /* init main configuration */ ngx_http_lua_create_srv_conf, /* create server configuration */ ngx_http_lua_merge_srv_conf, /* merge server configuration */ ngx_http_lua_create_loc_conf, /* create location configuration */ ngx_http_lua_merge_loc_conf /* merge location configuration */ }; 除了preconfiguration为NULL，其他都赋值了相应的回调函数。
指令数据结构 指令用于定义模块的配置文件的指令参数，主要是ngx_command_t的数据结构
struct ngx_command_s { ngx_str_t name; //指令名称，比如gzip ngx_uint_t type; //类型，出现的位置，比如http{}，server{}, loc{} char *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf); //解析指令的回调函数 ngx_uint_t conf; //在配置文件中偏移量 ngx_uint_t offset; //通常用于预设的解析方法配置项，这是配置模块的一个优秀设计，需要conf配合使用 void *post; //配置读取后的处理方法 }; typedef struct ngx_command_s ngx_command_t; 我们来看一下lua-nginx-module的ngx_command_t，这个模块的指令太多，我截取一部分看一下
static ngx_command_t ngx_http_lua_cmds[] = { ... /* access_by_lua "&lt;inline script>" */ { ngx_string("access_by_lua"), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF |NGX_CONF_TAKE1, ngx_http_lua_access_by_lua, NGX_HTTP_LOC_CONF_OFFSET, 0, (void *) ngx_http_lua_access_handler_inline }, /* access_by_lua_block { &lt;inline script> } */ { ngx_string("access_by_lua_block"), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF |NGX_CONF_BLOCK|NGX_CONF_NOARGS, ngx_http_lua_access_by_lua_block, NGX_HTTP_LOC_CONF_OFFSET, 0, (void *) ngx_http_lua_access_handler_inline }, ... ngx_null_command } 指令accee_by_lua的set函数ngx_http_lua_access_by_lua，post函数ngx_http_lua_access_handler_inline
总结 开发nginx第三方模块时，要严格ngx_module_t格式定义模块，只有这样nginx框架才能调用这个三方模块。</content></entry><entry><title>沃伦.巴菲特致股东的信-2021</title><url>https://lizj3624.github.io/post/warren-buffett-letter-2021/</url><categories><category>巴菲特致股东的信</category><category>财经</category></categories><tags><tag>巴菲特致股东的信</tag><tag>财经</tag></tags><content type="html"> 2022年2月26号巴菲特致股东的亲笔写发布，在2021年疫情和高通胀压力下，美元加息预期越来越迫切的情况下，科技股大幅度的回调，而伯克希尔营收逆势增长25%。 长期来看，1965-2021年，伯克希尔的年化收益为20.1%，显著超过标普500指数的10.5%, 1964-2021年伯克希尔达到令人吃惊的3641613%，也就是3.6万多倍多, &lsquo;股神&rsquo;还是那个股神。 巴菲特致股东的信2021-英文版, 中文版有聪明的投资者公众号翻译
北京时间2月26日晚间，伯克希尔哈撒韦公司官网公布了2021年年度报告，以及一份巴菲特每年亲自撰写的致股东信。
今年巴菲特大约是“跳着踢踏舞”的节奏写完伯克希尔的股东信。
股东信只有12页，篇幅越来越少，但这几年的感性色彩渐浓。
2021年，伯克希尔扬眉吐气地跑赢标普500指数，而公司营业利润在第四季度和全年都飙升，旗下业务在疫情带来的经济放缓中显著恢复生机。
伯克希尔2021年度营业收入总计 274.55 亿美元，比 2020 年的 219.92 亿美元增长了 25.2%。
巴菲特在 2021 年回购了创纪录数量的伯克希尔股票，总额达到约 270 亿美元。
在今年的信中，巴菲特连用“惊讶”一词。确实，至少这张成绩单对于股东和市场而言，称得上是惊喜的。
股东信最值得关注的几点，聪明投资者特别标注出来：
累计回报3.6万倍，复利之杖的神力！ 伯克希尔去年跑赢标普500指数0.9个百分点。
长期来看，1965-2021年，伯克希尔的年化收益为20.1%，显著超过标普500指数的10.5%。
尤其是看累计回报，1964-2021年伯克希尔达到令人吃惊的3641613%，也就是3.6万多倍多，而截至2020年的总回报是2.8万倍。
好吧，这个数字对于并没有可能参与始终的我们来说，没什么意义，但至少看到了活生生的例子，就是复利之杖的神力。
虽然并不控股，巴菲特还是把苹果列为“我们的四大巨头”。 考虑到其他三巨头都是伯克希尔控股业务，可见苹果以市值而论对于伯克希尔的贡献之大。
买入苹果不是很早的事情。巴菲特其实是在2016 年，在投资副手 Todd和 Ted的影响下开始购买苹果股票。到 2018 年年中，伯克希尔已经累计持有苹果5% 的股份，价值 360 亿美元。
如今，苹果的投资现在价值超过 1600 亿美元，占伯克希尔股票投资组合的 40%。
2021年巴菲特并没有增减苹果股票，但因为库克股票回购策略，让投资者“不必动一根指头”就增加了收益。
他对回购的作用一如既往地激赏。
铁路和能源两个支柱业务，去年也是创纪录表现。 BNSF（美国伯灵顿北方圣太菲铁路运输公司）和BHE（伯克希尔哈撒韦能源公司）去年净利润分别达到60亿美元、40亿美元，都创了纪录。
伯克希尔第四季度的营业利润飙升 45%，都要归功于其铁路、公用事业和能源业务在疫情对经济的打击中持续反弹。
2021年回购花了点钱出去，伯克希尔目前仍然持有1440亿美元现金。 2020年，伯克希尔已经拿出 240多亿美元回购股份，当时巴菲特就说2021年还将继续加大回购力度。
果然，拿出了270亿美元。
巴菲特持续回购，还是认为伯克希尔价值被低估的，按他的心意应该想要买更多。问题是，公司股东比较惜售，要大体量回购，只能慢慢来。
巴菲特在比亚迪上赚了32倍，2021年一股没卖 比亚迪现在依然是伯克希尔第八大重仓股（非控股的公司中）。
2008年9月，伯克希尔以每股8港元的价格购买2.25亿股比亚迪H股，总金额约2.3亿美元，并一路持有。年报显示，巴菲特在比亚迪的投资上已赚了32倍，但2021年一股都没卖，虽然比亚迪的“超级铁粉”李录，都在连续减持套现。
讲了一则轶事，没有TTI的保罗·安德鲁斯就不会有后来收购BNSF。 去年3月，创始人兼首席执行官保罗·安德鲁斯去世。50年来，安德鲁斯带领TTI取得非凡成就，成为业内卓越的电子元器件分销商之一。
TTI在2007年成为伯克希尔旗下子公司。巴菲特很详细地回忆跟安德鲁斯初次相见以及合作十几年的过往，所有赞美其实可以归为两句话：
安德鲁斯是位真正的企业家，不仅经营厉害，而且品格高尚；
如果没有当年投TTI，也就不会有2009年因为要参观TTI选择在沃斯堡开伯克希尔董事会，也就不会有后面投BNSF的事儿。
巴菲特把这归功于安德鲁斯给他的好运气。
巴菲特预测，未来一个世纪，BNSF将是伯克希尔乃至美国的最核心的资产。
今年股东聚会将在奥马哈重启，定于4月29日-5月1日。
希望顺利。
以下为聪明投资者的全文精译：
致伯克希尔哈撒韦公司股东：
查理·芒格是我的长期合作伙伴，我的工作是管理他的部分资产。能获得他的信任，我感到非常荣幸。
我们有责任向股东们报告大家想知道的情况。我们非常开心能够通过这封年度信件以及年度会议来与股东们直接沟通。
我们的政策是平等对待所有股东，因此我们不与分析师或大型机构进行讨论。我们会尽可能地在周六早上发布重要的信息，以便在周一开盘前，让股东和媒体有尽量多的时间来消化。
伯克希尔公司定期向SEC提交的年度10-K报告中列出了大量伯克希尔公司的事实和数据，这些也会在K-1至K-119页上呈现。
一些股东会觉得这些细节引人入胜，也有其他股东更愿意了解我和查理认为的在伯克希尔出现的那些新的或有趣的东西。
但在2021年，这些几乎没有。
不过，我们确实在提高公司股票的内在价值方面取得了合理进展，这项任务是我57年来的首要职责，而且未来一直是。
股东们拥有什么 伯克希尔拥有各种各样的公司，有些是全资控股，有些只是部分持股。
后者主要由美国大公司的可交易的普通股组成。
此外，我们还拥有一些海外资产，并参与了一些合资企业以及其他类型的合作项目。
无论我们的所有权形式如何，我们的目标都是对那些拥有护城河以及一流CEO的企业进行有意义的投资。
请特别注意，我们持有股票是基于我们对企业长期业务表现的预期，而不是拿来作为交易的工具。
这一点至关重要：查理和我不是在选股票，我们是在选商业模式和企业。
我也曾犯了很多错。所以最终结果是，我们广泛投资的企业中，包括一些具有真正非凡的企业，以及一些表现还不赖的企业，当然也有不怎么样的。
我们通过股票市场来投资，因为有时确实可以用便宜价格买到非常优秀的企业。这种“守株待兔”的做法在谈判交易中太罕见了，也不太会普遍存在。
但在二级市场，可以随时交易，错了也容易纠正。
惊讶，惊讶 以下是一些关于公司的信息，即使是经验丰富的投资者也常常感到惊讶：
（1）许多人认为伯克希尔是一个庞大而有点奇怪的金融资产组合。事实上，伯克希尔拥有并运营的美国“基础设施”资产——在我们的资产负债表上被归类为不动产、厂房和设备——比其他任何美国公司都多。
虽然这一优势从来不是我们追求的目标，但是这已经成为事实。
截至年底，伯克希尔的资产负债表上所记录的国内基础设施资产价值为1580亿美元。
这一数字在去年有所增加，未来还会继续，因为伯克希尔将持续前进。
（2）伯克希尔每年都要缴纳大量的联邦所得税。2021年我们就缴纳了33亿美元，而美国财政部报告的企业所得税收入总额为4020亿美元。此外，伯克希尔还缴纳了大量的州税和外国税。
可以说，伯克希尔的股东们“坐在办公室里都能为国做贡献”。
伯克希尔的历史生动说明了政府和美国企业之间那种无形又难以言说的纽带关系。
1955年初，伯克希尔精纺和哈撒韦制造同意合并他们的业务。在请求股东批准的过程中，这两家备受尊敬的新英格兰纺织公司对此次合并寄予厚望。
例如，哈撒韦的询价向股东保证“资源和管理的结合将造就纺织行业最强大、最高效的组织之一。”当时担任该公司顾问的雷曼兄弟也非常赞同这一乐观的说法。
我敢肯定，对于福尔河（伯克希尔）和新贝德福德（哈撒韦）来说，这是令人愉快的日子。然而，当乐队停止演奏、银行家们回家后，股东们将面临一场灾难。
在合并后的9年里，伯克希尔的所有者目睹了公司的净资产从5140万美元跌至2210万美元，部分是由于股票回购、欠考虑的股息政策以及工厂停产导致的。
但数千名员工9年的努力也带来了运营亏损。伯克希尔的困境并不罕见：新英格兰纺织业已经悄然进入了漫长且不可逆的死亡之旅。
在合并后的9年里，美国财政部也因伯克希尔而遇到了麻烦。在此期间内，公司只向政府缴纳了337,359美元的所得税——每天只有可怜的100美元。
1965年初，情况发生了变化。
伯克希尔有了新的管理层，重新分配了可用现金，并将所有收益基本都引导到了各种良好的业务中，其中大部分业务多年来一直保持良好。
收益的再投资与复利的力量结合在一起发挥了神奇的作用，股东们也因此赚钱了。
应该指出的是，伯克希尔的股东并不是这一航向调整中唯一受益者。背后“沉默的伙伴”——美国财政部持续从公司收取了数百亿美元的所得税。
还记得之前的每天100美元吗？现在，伯克希尔每天向财政部支付大约900万美元。
公平地说，对于我们的政府合作伙伴，我们的股东应该承认——事实上应该大肆宣扬——伯克希尔之所以有这样的繁荣，就是因为公司在美国。
如果没有伯克希尔，我们的国家在1965年以来的这些年里依旧可以取得辉煌的成就。然而，如果我们不是在美国，伯克希尔永远不会变成今天这个样子。
所以当你看到国旗时，请说声谢谢。
（3）伯克希尔在1967年斥资860万美元收购了国家保险公司，现在已成为保险“浮存金”领域的世界领先者。
“浮存金”是我们持有并可以用于投资的，不属于我们的资金。
包括一笔来自人寿保险的资金量相对较小的钱，伯克希尔的浮存金总额已经从刚进军保险领域时的1900万美元增长到了现在的1470亿美元。
到目前为止，这些浮动资金的成本几乎为零。虽然我们经历了保险损失加上运营费用超过保费的若干年份，但总体而言，我们获得了55年的适度利润。
同样重要的是，浮存金是非常具有粘性的。由于我们保险业务产生的资金每天都在变动，但总金额不会急剧下降，因此当用浮存金投资时，我们可以考虑长期投资。
如果你还不熟悉浮存金的概念，请参阅A-5页上的详细说明。
令人惊讶的是，去年我们的浮存金增加了90亿美元，这对伯克希尔公司的所有者来说非常重要，虽然没有反映在我们的GAAP（“公认会计原则”）的收益和净值报告中。
我们在保险业创造的巨大价值，很大程度上要归功于伯克希尔公司在1986年聘用了Ajit Jain（阿吉特·贾）。
我们第一次见面是在一个周六的上午，当时我就询问阿吉特在保险行业的经历，他的回答是“没有。”
我说“没有人是完美的”，然后雇佣了他。
那是我的幸运日：阿吉特实际上是一个非常完美的选择。更棒的是，35年后，他依然如此。
关于保险的最后想说的是：我认为伯克希尔的浮存金很可能——但远不能保证——不太会造成长期承保损失。
但我可以肯定的是，未来几年里会经历承保损失，而且涉及金额不小。
当然，伯克希尔在应对灾难性事件方面的能力是其他保险公司无法媲美的，而且这一优势在我和查理离开后还将持续保持下去。
我们的四巨头 通过伯克希尔，我们的股东拥有数十家企业，而其中一些公司也有自己的子公司。例如，Marmon有100多个独立业务，从铁路车辆租赁到医疗设备制造等等。
（1）尽管如此，我们“四大巨头”公司的运营占了伯克希尔公司价值的很大一部分。
领头的是我们的保险业务，伯克希尔拥有其100%的股份。我们之前也描述过该业务的巨大的浮存金价值，我们用这些浮存金不断投资以支持保险的最终保障承诺，结果投资规模越滚越大。
保险业务是为伯克希尔公司量身定做的，它永远不会过时，而且业务销量通常会随着经济增长和通货膨胀而不断增长。
此外，诚信和资本将一直非常重要，我们公司能够而且一定能表现得越来越好。
当然，也有其他一些保险公司拥有优秀的商业模式和前景。然而，复制伯克希尔的运营模式几乎是不可能的。
（2）苹果——以年终市值计算的亚军——是另外一种不同的持股方式。
我们对其的所有权仅为5.55%，高于一年前的5.39%，这个增幅感觉不值一提。
但考虑到苹果2021年的收益中，每0.1%的持股都是1亿美元。我们并没有花费伯克希尔的钱来进行增持，是苹果的回购起了作用。
重要的是，要知道伯克希尔的GAAP收益报告中只计算了苹果的股息。
去年，苹果支付了我们7.85亿美元的股息。然而，我们在苹果“持股份额”的利润达到了惊人的56亿美元。
公司保留的大部分资金用于回购苹果股份，我们对此表示赞赏。苹果杰出的首席执行官蒂姆·库克将苹果产品的用户视为自己的初恋，这很合理，但蒂姆的其他支持者也从他的管理风格中受益匪浅。
（3）BNSF（伯灵顿北方圣太菲铁路）是我们的第三大持仓，它依然是美国商业的头号动脉，是美国和伯克希尔不可或缺的资产。
如果BNSF运输的产品改用卡车运输，那么美国的碳排放量将会井喷。
2021年，BNSF的利润达到了创纪录的60亿美元。
这里需要指出的是，我们谈论的是我们喜欢的老式算法：扣除利息、税收、折旧、摊销和所有形式计提后的利润。（我们的这种算法也发出了一个警告：随着股市上涨，对收益的进行欺骗性的“调整”已经变得更加频繁，也更加不切实际。恕我直言，牛市让大家越来越膨胀了……）
BNSF的火车去年行驶了1.43亿英里，运送了5.35亿吨货物。
这两项成就都远远超过了其他任何一家美国铁路公司。大家可以为自己的铁路感到骄傲。
（4）我们的最后一只重仓股BHE（伯克希尔哈撒韦能源公司）在2021年赚了创纪录的40亿美元。
比2000年伯克希尔第一次购买BHE的股票时的利润（1.22亿美元增）增长了30多倍。现在，伯克希尔持有该公司91.1%的股份。
BHE的社会成就与其财务业绩一样引人注目。该公司在2000年没有风能，也没有太阳能发电。当时，它只是被认为是美国庞大的电力事业行业中一个相对较新的、较小的参与者。
随后，在大卫·索科尔和格雷格·阿贝尔的领导下，BHE成为了一家公用事业公司（请不要抱怨），以及美国风能、太阳能和输电领域的领军企业。
关于格雷格的这些成就的报告位于A-3和A-4页。你会发现那里的介绍绝对不是时下流行的“洗绿”（ 指企业伪装成环境之友,试图掩盖对社会和环境的破坏,以此保全和扩大自己的市场或影响力）故事。
自2007年开始，BHE每年都会详细介绍其在可再生能源和输电方面的计划和业绩。
想进一步了解这些信息，请访问BHE的网站brkenergy.com。在那里，你会看到该公司长期以来一直在实施应对气候变化的举措，这些举措耗尽了其所有的收入。但未来有更多的机会——BHE拥有良好的管理、经验、资本，可以满足国家对大型电力项目的需求。
现在让我们来谈谈我们没有控股的公司，这个表再次提到了苹果。
下表列出了我们持仓市值最大的15只股票，其中几只是伯克希尔的两位长期投资经理托德•库姆斯（Todd Combs）和特德•韦施勒（Ted Weschler）选择的。
到2021年底，这对明星投资经理对340亿美元的投资拥有完全的权力，其中许多投资都没有达到我们在表中使用的门槛值。
此外，托德和特德管理的相当大一部分资金存在伯克希尔旗下企业的各种养老金计划中，这些计划的资产未包含在此表中。 美国国债 伯克希尔的资产负债表包括1440亿美元的现金和现金等价物（不包括持有的BNSF和BHE）。其中，1200亿美元以美国国债的形式持有，全部在一年之内到期。
1%的公开市场中的国债，有大约半数资金来自伯克希尔。
查理和我已承诺，伯克希尔将始终持有超过300亿美元的现金和等价物（包括除BNSF和BHE以外的子公司）。
我们希望伯克希尔在财务上坚不可摧，永不依赖陌生人（甚至朋友）的恩惠。
我们希望夜夜安枕，希望我们的债权人、保险投保人和股东们也如此。
但1440亿美元，会不会太多了？
我向你保证，这笔巨款并不是爱国主义的疯狂表现。查理和我也没有失去对“拥有一家企业”的压倒性偏好。
事实上，80年前的1942年3月11日，当我购买了三股Cities Services优先股时，我第一次表现出对拥有企业的热情。
它们的成本是114.75美元，花费了我所有的积蓄。（当天道琼斯工业平均指数收于99点，这一事实告诉我们：永远不要做空美国。）
在我最初遭受亏损之后，我总是将至少80%的净资产投资在股票上。在那段时间里，我最青睐的状态是满仓—现在仍然如此。
伯克希尔目前的仓位在80%左右，是因为我没找到符合我们长期持有标准的整个公司或其中一小部分（流通股）。
查理和我在过去不时忍受着类似的现金头寸很大的状况。这些时期从来都不令人愉快，也不是永久性的。
幸运的是，在2020年和2021年，我们找到一个温和的、有吸引力的替代现金的方案。
股票回购 我们可以通过三种方式增加股东的投资价值。
第一种方式始终是我们心仪的首选：通过内部增长或收购来提高伯克希尔控股企业的长期盈利能力。现在，内部增长带来的回报远高于收购。然而，与伯克希尔的资源相比，这些机会的规模很小。
我们的第二个选择是购买公开交易的优秀及伟大企业的流通股。有时，这样的可能性既多又极具吸引力。然而如今，我们几乎没有发现什么能让我们兴奋的东西。
这在很大程度上是因为一个真理：长期低利率推动所有生产性投资的价格上涨，无论是股票、地产、农业、原油等等。其他因素也会影响估值，但利率始终很重要。
我们创造价值的最后一条途径是回购伯克希尔的股票。
通过这个简单的举动，我们增加了股东在伯克希尔众多控股和非控股企业中的份额。
当价格跟价值相比很便宜时，这就是我们股东增加财富的最简单、最确定的方式。（除了为持续股东增加价值外，其他几方也获得了收益：回购对回购股份的卖方和社会都有一定的好处。）
随着其他途径越来越没有吸引力，回购对伯克希尔股东来说就很有意义了。
在过去两年中，我们回购了截止2019年末外部流通股的9%，总成本517亿美元。这笔支出使我们的长期股东拥有伯克希尔所有业务能够多出大约10%，无论这些业务是全资拥有（如BNSF和GEICO）还是部分拥有（如可口可乐和穆迪）。
我想强调的是，要使伯克希尔的股票回购有意义，我们的股票必须提供适当的价格。
我们既然不想为其他公司的股票多付钱，那如果我们在回购伯克希尔股票时支出过高，也得不偿失。
从去年年底到2022年2月23日以来，我们以12亿美元的成本回购了更多股票。我们的胃口仍然很大，但始终取决于价格。
必须得说，伯克希尔股票的回购机会有限，因为它拥有高品质的投资者。
如果我们的股票是被短期投机者大量持有，其价格波动和交易量都会大幅放大，这样可能给我们创造更多有价值的回购机会，让长期股东们从投机性回购中获利。
尽管如此，查理和我还是更喜欢我们现在的股东。
最后，伯克希尔所特有的容易被忽视的价值计算：正如我们已经讨论过的，正确的保险“浮存金”对我们来说是很有价值的。
事实上，回购会自动增加每股“浮存金”的金额。
这一数字在过去两年中增长了25%，从每股“A”类股79,387美元上升到99,497美元，这项收益意义很大。
正如前面提到的，这要归功于回购。
一个了不起的人和一个了不起的事业 去年，保罗·安德鲁斯去世了。
保罗是总部位于沃斯堡的伯克希尔子公司TTI的创始人兼首席执行官。
在他的一生中，无论是在事业上还是在个人追求上，保罗都不声不响地表现出了查理和我所钦佩的所有品质。他的故事应该被讲出来。
1971年，保罗在通用动力公司做采购代理。而在失去一份巨额的国防合同后，该公司解雇了包括保罗在内的数千名员工。
由于彼时他的第一个孩子即将出生，保罗决定赌上一把，用自己的500美元积蓄创建了德克萨斯电子公司(Tex-Tronic，后来改名为TTI)。
该公司成立的目标是销售小型电子元器件，第一年的销售额达到了总销售额11.2万美元。今天，TTI的产品市场超过100万种，年销售额达77亿美元。
但回到2006年：63岁的保罗发现自己与家人、工作和同事相处得很幸福。但他有一个挥之不去的担忧，因为他最近亲眼目睹了一个朋友的早逝，以及随之而来的对其家庭和生意造成的灾难性后果，这让他的担忧更加严重。
保罗在2006年问自己，如果他意外死亡，许多依靠他的人将会发生什么?
整整一年，保罗都在为自己的选择而苦苦挣扎。把公司卖给竞争对手？从严格的经济学观点来看，这条路线最有意义。毕竟，竞争对手可以预见到利润丰厚的“协同效应”——当收购者削减TTI的重复职能时，可以实现成本节省。
但是……这样的买家肯定还会保留其首席财务官、法律顾问和人力资源部门。
因此，TTI公司的同一职能部门将被集体裁员。而且，如果需要一个新的配送中心，收购方的家乡城市肯定会比沃斯堡更受青睐。
不管财务效益如何，保罗很快就得出结论，把公司卖给竞争对手不适合他。接下来，他考虑寻找一个金融买家——这个物种曾被恰当地称为杠杆收购公司。然而保罗知道，这样的买家会专注于“退出策略”。
谁知道那会是什么呢？ 考虑到这一切，保罗发现自己没有兴趣将他35年以来苦心经营的成果交给一个中间商。
当保罗见到我时，他解释了为什么他把这两个备选买家排除在外。然后他用比这更委婉的措辞总结了他的困境——“在考虑了一年其他选择后，我想把公司卖给伯克希尔，因为你是唯一剩下的人。”
所以我提出了报价，保罗答应了。一次会面，一顿午餐，达成了一笔交易。
用“从此过上了幸福的生活”来形容我俩都显得平淡无奇。
当伯克希尔收购TTI时，该公司雇佣了2387名员工。现在这个数字是8043。其中很大一部分增长发生在沃斯堡及其周边地区。公司的盈利增长了673%。
每年，我都会打电话给保罗，告诉他，他的薪水应该大幅增加。而每年，他都会告诉我，“我们可以明年再谈，沃伦，我现在太忙了。”
当我和格雷格•阿贝尔参加保罗的追悼会时，我们见到了他的子孙辈、长期合作伙伴（包括TTI的第一位员工），和约翰•罗奇（John Roach），他是伯克希尔于2000年收购的沃斯堡一家公司的前首席执行官。正是约翰把保罗引到奥马哈的，他本能地知道我们会是绝配。
在追悼会上，我和格雷格听说了保罗默默支持的许多人和组织。他的慷慨非同寻常——始终致力于改善他人的生活，尤其是沃斯堡的人们。
在所有方面，保罗都是个杰出的人。
运气——偶尔是非凡的运气——在伯克希尔发挥了作用。如果保罗和我没有共同的朋友——约翰•罗奇，TTI也不会在我们这里安家。但这充足的运气仅仅是个开始。TTI很快就将伯克希尔引向了其最重要的收购。
每年秋天，伯克希尔的董事们都会聚集在一起，听我们的几位高管讲话。
我们有时会根据近期收购的地点来选择会议地点，这意味着董事们可以与新子公司的首席执行官会面，并了解更多关于被收购方的活动。
在2009年秋天，我们因此选择了沃斯堡，以便我们可以访问TTI。当时，总部同样位于沃思堡的BNSF是我们持有股份第三多的公司。尽管有这么多的股份，我却从来没有去过这家铁路公司的总部。
我的助理黛布·博萨内克（Deb Bosanek）将董事会的开幕晚宴安排在10月22日。与此同时，那天我安排早些时候会见马特·罗斯（Matt Rose），他是BNSF的首席执行官。
我一直钦佩他的成就。当我确定这个日期的时候，我没有想到我们的聚会将与BNSF在22日晚些时候发布第三季度盈利报告同时举行。
市场对这家铁路公司的业绩反应不佳。“大衰退”在那年第三季度全面爆发，BNSF的收益情况反映了这种衰退。经济前景也很黯淡，华尔街对铁路也不友好。
第二天，我再次与马特会面，并建议伯克希尔将为铁路公司提供一个比作为上市公司所能期望的更好的长期归宿。我还告诉他伯克希尔愿意支付的最高价格。
马特将这一提议转达给了他的董事和顾问。经过忙碌的11天后，伯克希尔和BNSF宣布了一项确定交易。
在这里，我冒险做出一个罕见的预测：BNSF未来一个世纪，成为伯克希尔乃至美国最核心的资产。
如果保罗•安德鲁斯没有将伯克希尔视为TTI的合适归宿地，BNSF的收购就永远不会发生。
致谢 70年前，我教授了我的第一堂投资课。从那时起，我几乎每年都很享受与各个年龄段的学生一起工作，最终我在2018年从这个追求中 &ldquo;退休&rdquo;。
一路走来，我最艰难的听众是我孙子的五年级班级。这些11岁的孩子在座位上扭来扭去，茫然地看着我，直到我提到可口可乐(Coca-Cola)及其著名的秘密配方时。瞬间，每个人都举起手来，我明白了“秘密”对孩子们来说是一种诱惑。
教学就像写作一样，帮助我发展和理清了自己的思路。查理把这种现象称为猩猩效应：如果你和一只猩猩坐在一起，向它仔细解释你所珍视的一个想法，你可能会留下一只迷惑不解的灵长类动物，但你自己的思维会更清晰。
和大学生交谈则要有效得多。我敦促他们在：
（1）专业领域找工作；
（2）如果他们不差钱的话，找他们想选择的人一起工作。
我承认，经济现实可能会干扰这种选择。
即便如此，我还是敦促学生们永远不要放弃追求，因为当他们找到那种热爱的工作时，他们就不再是“社畜”了。
查理和我在经历了一些早期的挫折后，走上了这条自由的道路。我们都曾在我祖父的杂货店里做兼职——查理1940年、我1942年。我们都被分配了无聊的任务，报酬也少，这绝对不是我们想要的。
后来，查理开始从事法律工作，而我则尝试着卖证券。我们对工作的满意度仍然不高。
最后，在伯克希尔，我们找到了自己喜欢做的事情。除了极少数例外，我们现在已经与我们喜欢和信任的人“工作”了几十年。
与保罗•安德鲁斯（Paul Andrews）或我去年说过的伯克希尔大家庭这样的经理人共事，是一种生活乐趣。
在我们的总部，我们雇佣正派和有才华的人，没有一个人是笨蛋。每年的平均流动率大概是一个人。
不过我想强调另一件事，它使我们的工作变得有趣和令人满意——为股东工作。对查理和我来说，没有什么比获得个人长期股东的信任更值得的了。
几十年来，他们加入我们，期望我们成为他们资金的可靠托管人。
显然，我们不能选择我们的股东，如果我们的经营形式是合伙的话，我们可以这样做。任何人现在都可以购买伯克希尔的股票，并打算很快再出售这些股票。
当然，我们会有一些这样的股东，就像我们会有指数基金持有大量伯克希尔股票，只是因为它们被要求这么做。
伯克希尔拥有一个庞大的个人和家庭团队，他们选择加入我们的行列，且“至死不渝”，这非常不同寻常。通常他们把储蓄的很大一部分——对有些人来说可能是过多的存款——托付给我们。
这些股东有时会觉得，伯克希尔可能远不是他们能做出的最佳选择。但他们会补充说，伯克希尔在他们最满意的公司中已经排名非常靠前。
平均而言，那些对自己的投资感到满意的人，会比那些被不断变化的新闻、传言和承诺所影响的人会取得更好的结果。
长期个人股东既是我和查理一直寻求的“合作伙伴”，也是我们在伯克希尔做出决策时一直考虑的目标群体。
我们想对他们说：“为你们‘工作’感觉很好，非常感谢你们的信任。”
年度股东大会 日期已经确定！伯克希尔将于4月29日星期五至5月1日星期日在奥马哈举行年度股东大会。详细情况见A-1和A-2页。奥马哈和我都热切期待你们的到来。
在这封信的结尾，我顺便打个广告。“表弟”吉米·巴菲特设计了一艘浮筒式“派对”游艇，目前由伯克希尔的子公司Forest River制造。这艘船将于4月29日在伯克希尔股东大会上发布。限时两天内，股东们可以以10%的折扣购买吉米的杰作。你们的董事长会买一艘给家人使用，快加入我们吧。
2022年2月26日 沃伦·巴菲特</content></entry><entry><title>OpenResty中的lua协程</title><url>https://lizj3624.github.io/post/ngx_lua/</url><categories><category>OpenResty</category><category>nginx</category><category>ngx_lua</category></categories><tags><tag>OpenResty</tag><tag>nginx</tag><tag>ngx_lua</tag></tags><content type="html"> OpenResty是一个基于nginx与Lua的高性能Web平台，其内部集成了大量精良的Lua库、第三方模块以及大多数的依赖项。 用于方便地搭建能够处理超高并发、扩展性极高的动态Web应用、Web服务和动态网关。 研究和学习ngx_lua以及lua协程对理解OpenResty源码很有帮助, 收集一些ngx_lua源码讲解的文章。
ngx_lua nginx是事件驱动的异步处理方式，Lua语言本身是同步处理，但是Lua原生支持协程，给nginx与Lua的结合提供了机会。
nginx可以同时处理数以万计的网络连接，Lua可以同时存在很多协程，简单一点想，对每个到来的网络连接，创建一个新的协程去处理，处理完毕后释放协程。 和Apache为每个连接fork一个进程处理的流程十分相似，只不过多个进程换成了多个协程。
协程相比较进程占用资源很小，协程之间的切换性能消耗非常小，几乎就相当于函数调用一样。以同步的方式写程序，实现了异步处理的效率。当然实际的编程实现并没有多进程那么简单。
在Lua中，每个协程对应有一个lua_State结构体， 这个结构体中保存了协程的所有信息。所有的协程共享一个global_State结构体，这个结构体保存全局相关的一些信息，主要是所有需要垃圾回收的对象。
通常创建Lua执行环境都是从lua_open(即luaL_newstate)开始, lua_open会创建一个global_State结构，创建一个协程作为主协程ngx_http_lua_module是在读取配置后的postconfiguration阶段创建Lua环境的， 除此之外还做了一个额外的操作，主要是创建了名为ngx，类型为table的全局变量，所有Lua与nginx的交互都是通过ngx这个全局变量来实现的，如ngx.sleep, ngx.socket等方法都在这个的table中。
nginx中请求的处理是分阶段的，ngx_http_lua_module在多个阶段挂载了回调函数，这里ngx_lua的图. 在rewrite, access 等多个阶段，都有相应的*_by_lua*处理。
这里以access阶段为例。先通过ngx_http_lua_get_lua_vm获取主协程的lua_State结构体L，再通过ngx_http_lua_cache_loadbuffer获取解析后的lua代码， 然后通过ngx_http_lua_access_by_chunk执行lua代码。
ngx_int_t ngx_http_lua_access_handler_inline(ngx_http_request_t *r) { ngx_int_t rc; lua_State *L; ngx_http_lua_loc_conf_t *llcf; llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); L = ngx_http_lua_get_lua_vm(r, NULL); /* load Lua inline script (w/ cache) sp = 1 */ rc = ngx_http_lua_cache_loadbuffer(r->connection->log, L, llcf->access_src.value.data, llcf->access_src.value.len, llcf->access_src_key, (const char *) llcf->access_chunkname); if (rc != NGX_OK) { return NGX_HTTP_INTERNAL_SERVER_ERROR; } return ngx_http_lua_access_by_chunk(L, r); } 在balancer_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua阶段中，直接在主协程中执行代码，而在access，content等其他几个阶段中，会创建一个新的协程去执行此阶段的lua代码。表现在API层面，两者的区别就是能否执行ngx.sleep, ngx.socket, ngx.thread这几个命令。
Lua中的协程可以随时挂起，一段时间后继续运行。在access等阶段会新建协程， 新的协程只处理一个请求，可以方便的挂起来，不会影响其他的协程。而在log阶段没有创建新的协程，主协程是不能执行ngx.sleep等阻塞操作的。
Lua中的协程也是GC对象，会被系统进行垃圾回收时销毁掉，为了保证挂起的协程不会被GC掉，ngx_http_lua_module在全局的注册表中创建了一个table，新创建的协程保存在table中，协程执行完毕后从table中注销，GC时就会将已注销的协程回收掉。
ngx_http_lua_module初始Lua运行环境时，执行ngx_http_lua_init_registry函数，在注册表创建了几个table，key为ngx_http_lua_coroutines_key的table保存所有的协程。
static void ngx_http_lua_init_registry(lua_State *L, ngx_log_t *log) { ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0, "lua initializing lua registry"); /* register a table to anchor lua coroutines reliably: **/ lua_pushlightuserdata(L, &amp;ngx_http_lua_coroutines_key); lua_createtable(L, 0, 32 /* nrec */); lua_rawset(L, LUA_REGISTRYINDEX); /* create the registry entry for the Lua request ctx data table */ lua_pushliteral(L, ngx_http_lua_ctx_tables_key); lua_createtable(L, 0, 32 /* nrec */); lua_rawset(L, LUA_REGISTRYINDEX); /* create the registry entry for the Lua socket connection pool table */ lua_pushlightuserdata(L, &amp;ngx_http_lua_socket_pool_key); lua_createtable(L, 0, 8 /* nrec */); lua_rawset(L, LUA_REGISTRYINDEX); #if (NGX_PCRE) /* create the registry entry for the Lua precompiled regex object cache */ lua_pushlightuserdata(L, &amp;ngx_http_lua_regex_cache_key); lua_createtable(L, 0, 16 /* nrec */); lua_rawset(L, LUA_REGISTRYINDEX); #endif lua_pushlightuserdata(L, &amp;ngx_http_lua_code_cache_key); lua_createtable(L, 0, 8 /* nrec */); lua_rawset(L, LUA_REGISTRYINDEX); } nginx中处理请求都是围绕ngx_http_request_t结构体进行了，一个ngx_http_request_t结构体代表了当前正在处理的一个请求。 ngx_http_lua_module处理Lua脚本时要与nginx进行交互，也要通过这个结构体实现。 为此在创建新的协程后，将相关联的ngx_http_request_t的指针保存在了lua_State的全局变量中。
如下所示，通过ngx_http_lua_set_req将请求与协程关联。
static ngx_inline void ngx_http_lua_set_req(lua_State *L, ngx_http_request_t *r) { lua_pushlightuserdata(L, r); lua_setglobal(L, ngx_http_lua_req_key); } 通过ngx_http_lua_get_req从lua_State中获取协程关联的请求。
static ngx_inline ngx_http_request_t * ngx_http_lua_get_req(lua_State *L) { ngx_http_request_t *r; lua_getglobal(L, ngx_http_lua_req_key); r = lua_touserdata(L, -1); lua_pop(L, 1); return r; } 下面这个是ngx.get_method的API的实现，很简单的逻辑，通过ngx_http_lua_get_req获取请求的ngx_http_request_t结构体， 从结构体中把代表请求方法字符串返回。ngx_http_lua_module提供的API大都通过这种方式来实现。
static int ngx_http_lua_ngx_req_get_method(lua_State *L) { int n; ngx_http_request_t *r; n = lua_gettop(L); if (n != 0) { return luaL_error(L, "only one argument expected but got %d", n); } r = ngx_http_lua_get_req(L); if (r == NULL) { return luaL_error(L, "request object not found"); } ngx_http_lua_check_fake_request(L, r); lua_pushlstring(L, (char *) r->method_name.data, r->method_name.len); return 1; } 引用参考文章 ngx_lua中的lua协程
OpenResty讲解
OpenResty中ngx_lua
OpenResty精华整理</content></entry><entry><title>nginx epoll惊群</title><url>https://lizj3624.github.io/post/ngx-epoll/</url><categories><category>nginx</category><category>epoll</category></categories><tags><tag>nginx</tag><tag>epoll</tag></tags><content type="html"> nginx是目前比较流行的高性能的负载均衡，反向代理，静态web服务器，它的高性能主要是基于epoll(Linux)的事件框架。
nginx是开源，我们可以通过阅读源码分析它的epoll事件的实现。 还有epoll存在惊群的问题，看看nginx是如何解决的这个问题的。 从网络上收集整理一些资料，在此汇总一下，以便查阅。
惊群现象 首先，我们看看维基百科对惊群的定义,简而言之， 惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程， 但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。
accept惊群 考虑如下场景：
主进程创建socket、bind、 listeni之后，fork出多个子进程，每个子进程都开始循环处理accept这个socket。 每个进程都阻塞在accpet上，当一个新的连接到来时，所有的进程都会被唤醒，但其中只有一个进程会accept成功， 其余皆失败，重新休眠。这就是accept惊群。
那么这个问题真的存在吗？
事实上，历史上，Linux的accpet确实存在惊群问题，但现在的内核都解决该问题了。即当多个进程/线程都阻塞在对同一个socket的accept调用上时， 当有一个新的连接到来，内核只会唤醒一个进程，其他进程保持休眠，压根就不会被唤醒。
测试验证代码:
#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;netinet/in.h>#include &lt;sys/wait.h>#include &lt;stdio.h>#include &lt;string.h>#define PROCESS_NUM 10 int main() { int fd = socket(PF_INET, SOCK_STREAM, 0); int connfd; int pid; char sendbuff[1024]; struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); serveraddr.sin_port = htons(1234); bind(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)); listen(fd, 1024); int i; for(i = 0; i &lt; PROCESS_NUM; i++) { int pid = fork(); if(pid == 0) { while(1) { connfd = accept(fd, (struct sockaddr*)NULL, NULL); snprintf(sendbuff, sizeof(sendbuff), "accept PID is %d\n", getpid()); send(connfd, sendbuff, strlen(sendbuff) + 1, 0); printf("process %d accept success!\n", getpid()); close(connfd); } } } int status; wait(&amp;status); return 0; } 当我们对该服务器发起连接请求（用 telnet/curl 等模拟）时，会看到只有一个进程被唤醒。
关于 accept 惊群的一些帖子或文章：
Does the Thundering Herd Problem exist on Linux anymore? 历史上解决 linux accept 惊群的补丁讨论 其实，在linux2.6内核上，accept系统调用已经不存在惊群了（至少我在2.6.18内核版本上已经不存在）
epoll惊群 如上所述，accept已经不存在惊群问题，但epoll上还是存在惊群问题。即如果多个进程/线程阻塞在监听同一个listening socket fd的epoll_wait上， 当有一个新的连接到来时，所有的进程都会被唤醒。
考虑如下场景：
主进程创建socket、bind、 listen后，将该socket加入到epoll中，然后 fork出多个子进程，每个进程都阻塞在epoll_wait上，如果有事件到来， 则判断该事件是否是该socket上的事件，如果是说明有新的连接到来了，则进行accept操作。为了简化处理， 忽略后续的读写以及对accept返回的新的套接字的处理，直接断开连接。
那么，当新的连接到来时，是否每个阻塞在epoll_wait上的进程都会被唤醒呢？
很多博客中提到，测试表明虽然epoll_wait 不会像accept那样只唤醒一个进程/线程，但也不会把所有的进程/线程都唤醒。 例如这篇文章：关于多进程 epoll 与 “惊群”问题。
测试验证代码:
#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;sys/epoll.h>#include &lt;netdb.h>#include &lt;string.h>#include &lt;stdio.h>#include &lt;unistd.h>#include &lt;fcntl.h>#include &lt;stdlib.h>#include &lt;errno.h>#include &lt;sys/wait.h>#define PROCESS_NUM 10 static int create_and_bind (char *port) { int fd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); serveraddr.sin_port = htons(atoi(port)); bind(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)); return fd; } static int make_socket_non_blocking (int sfd) { int flags, s; flags = fcntl (sfd, F_GETFL, 0); if (flags == -1) { perror ("fcntl"); return -1; } flags |= O_NONBLOCK; s = fcntl (sfd, F_SETFL, flags); if (s == -1) { perror ("fcntl"); return -1; } return 0; } #define MAXEVENTS 64 int main (int argc, char *argv[]) { int sfd, s; int efd; struct epoll_event event; struct epoll_event *events; sfd = create_and_bind("1234"); if (sfd == -1) abort (); s = make_socket_non_blocking (sfd); if (s == -1) abort (); s = listen(sfd, SOMAXCONN); if (s == -1) { perror ("listen"); abort (); } efd = epoll_create(MAXEVENTS); if (efd == -1) { perror("epoll_create"); abort(); } event.data.fd = sfd; //event.events = EPOLLIN | EPOLLET; event.events = EPOLLIN; s = epoll_ctl(efd, EPOLL_CTL_ADD, sfd, &amp;event); if (s == -1) { perror("epoll_ctl"); abort(); } /* Buffer where events are returned */ events = calloc(MAXEVENTS, sizeof event); int k; for(k = 0; k &lt; PROCESS_NUM; k++) { int pid = fork(); if(pid == 0) { /* The event loop */ while (1) { int n, i; n = epoll_wait(efd, events, MAXEVENTS, -1); printf("process %d return from epoll_wait!\n", getpid()); /* sleep here is very important!*/ //sleep(2); for (i = 0; i &lt; n; i++) { if ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) || (!(events[i].events &amp; EPOLLIN))) { /* An error has occured on this fd, or the socket is not ready for reading (why were we notified then?) */ fprintf (stderr, "epoll error\n"); close (events[i].data.fd); continue; } else if (sfd == events[i].data.fd) { /* We have a notification on the listening socket, which means one or more incoming connections. */ struct sockaddr in_addr; socklen_t in_len; int infd; char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV]; in_len = sizeof in_addr; infd = accept(sfd, &amp;in_addr, &amp;in_len); if (infd == -1) { printf("process %d accept failed!\n", getpid()); break; } printf("process %d accept successed!\n", getpid()); /* Make the incoming socket non-blocking and add it to the list of fds to monitor. */ close(infd); } } } } } int status; wait(&amp;status); free (events); close (sfd); return EXIT_SUCCESS; } 发现确实如上面那篇博客里所说，当我模拟发起一个请求时，只有一个或少数几个进程被唤醒了。
也就是说，到目前为止，还没有得到一个确定的答案。但后来，在下面这篇博客中看到这样一个评论
这个总结，需要进一步阐述，看上去是只有4个进程唤醒了，而事实上，其余进程没有被唤醒的原因是你的某个进程已经处理完这个accept，内核队列上已经没有这个事件， 无需唤醒其他进程。你可以在epoll获知这个accept事件的时候，不要立即去处理，而是sleep下，这样所有的进程都会被唤起。
看到这个评论后，我顿时如醍醐灌顶，重新修改了上面的测试程序，即在epoll_wait返回后，加了个sleep语句，这时再测试，果然发现所有的进程都被唤醒了。
所以，epoll_wait上的惊群确实是存在的。
为什么Kernel不处理Epoll惊群 看到这里，我们可能有疑惑了，为什么内核对accept的惊群做了处理，而现在仍然存在epoll的惊群现象呢？
我想，应该是这样的：
accept确实应该只能被一个进程调用成功，内核很清楚这一点。但epoll不一样，他监听的文件描述符，除了可能后续被accept调用外，还有可能是其他网络IO事件的， 而其他IO事件是否只能由一个进程处理，是不一定的，内核不能保证这一点，这是一个由用户决定的事情，例如可能一个文件会由多个进程来读写。所以对epoll的惊群，内核则不予处理。
nginx解决惊群的方法 nginx的epoll框架 nginx主进程解析配置，将listen指令初始化到全局变量ngx_cycle的listening数组之中。此时监听套接字的创建、绑定工作早已完成。
nginx主进程fork出多个子进程(worker进程), 每个子进程执行ngx_worker_process_init, 为每个子进程创建epoll句柄。
每个子进程执行ngx_process_events_and_timers，这就进入到事件处理的核心逻辑了，如果开启 accept_mutex，每个进程争抢锁, epoll_wait等待处理网络事件。
accept_mutex锁 如果开启了accept_mutex锁，每个worker都会先去抢自旋锁，只有抢占成功了，才把socket加入到epoll中，accept请求后释放锁, accept_mutex锁也有负载均衡的作用。 accept_mutex效率低下，特别是在长连接的时候。因为长连接时，一个进程长时间占用accept_mutex锁，使得其它进程得不到accept的机会。因此不建议使用，默认是关闭的。
EPOLLEXCLUSIVE标识 EPOLLEXCLUSIVE是4.5+内核新添加的一个epoll的标识，Ngnix 在1.11.3之后添加了NGX_EXCLUSIVE_EVENT。 EPOLLEXCLUSIVE标识会保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的“惊群”问题。 不过任一时候只能有一个工作线程调用accept，限制了真正并行的吞吐量。
SO_REUSEPORT 选项 SO_REUSEPORT是惊群最好的解决方法，Ngnix在1.9.1中加入了这个选项，每个worker都有自己的socket，这些socket都bind同一个端口。 当新请求到来时，内核根据四元组信息进行负载均衡，非常高效。
Linux 3.9版本的内核对reuseport做了支持，在4.6版本内核做了优化，详细参看关于Linux UDP/TCP reuseport 二三事
总结 现在我们对惊群及Nginx的处理总结如下：
accept不会有惊群，epoll_wait才会。
Nginx的accept_mutex，并不是解决accept惊群问题，而是解决epoll_wait惊群问题。
说Nginx解决了epoll_wait惊群问题，也是不对的，它只是控制是否将监听套接字加入到epoll中。 监听套接字只在一个子进程的epoll中，当新的连接来到时，其他子进程当然不会惊醒了。
引用文章 accept与epoll惊群
Nginx是如何解决epoll惊群的
“惊群”，看看nginx是怎么解决它的
关于Linux UDP/TCP reuseport 二三事
重新实现reuseport逻辑，实现一致性哈希</content></entry><entry><title>区块链加密货币入门</title><url>https://lizj3624.github.io/post/blockchain/</url><categories><category>blockchain</category></categories><tags><tag>blockchain</tag><tag>bitcoin</tag><tag>cryptocurrency</tag></tags><content type="html"> 2008年10月31号加密hacker中本聪发表了比特币白皮书，2009年1月3日，创世区块诞生，比特币诞生， 区块链和加密货币的大门被打开，区块链加密货币经过10多年的发展已经被很多人所接受，现在还是发展初级阶段，未来大有可为，从现在开始学习区块链技术，今年争取拥有加密货币资产。
Bitcoin 比特币是有加密hacker中本聪由2009年1月3号创建。
比特币白皮书
精通比特币
比特币生态资源
Ethereum 以太坊是由维塔利克·布特林(V神)2013年提出的，发表了以太坊白皮书，支持智能合约。
以太坊白皮书
精通以太坊
以太坊生态资源
IPFS 星际文件系统(IPFS)是一个旨在实现文件的分布式存储、共享和持久化的网络传输协议，文件币(filecoin)。
IPFS Polkadot 波卡是由以太坊前CTO，以太坊黄皮书作者Gavin Wood博士创建，支持跨链。
波卡 Solana solana NFT NFT(非同质化代币)是一种被称为区块链数字账本上的数据单位，每个代币可以代表一个独特的数字资料，作为虚拟商品所有权的电子认证或证书。
OpenSea
NFT School
NFT Storage
DeFi 去中心化金融（英语：Decentralized finance，俗称DeFi）是一种创建于区块链上的金融，它不依赖券商、交易所或银行等金融机构提供金融工具，而是利用区块链上的智能合约（例如以太坊）进行金融活动。
DeFi Pulse
Compound
ENS 以太坊域名服务（Ethereum Name Service）是一个基于以太坊区块链的分布式、开放和可扩展的命名系统。 通俗地说，ENS就是区块链中的域名系统。 ENS 域名让人们没有必要再复制或输入冗长的区块链地址。
ENS
ENS中文介绍
Web3.0 图片引用indigo公众号</content></entry><entry><title>Kubernetes入门</title><url>https://lizj3624.github.io/post/kubernetes-primer/</url><categories><category>kubernetes</category></categories><tags><tag>kubernetes</tag><tag>k8s</tag><tag>cloudnative</tag></tags><content type="html"> 以容器(docker)和容器编排(kubernetes)的云原生技术栈在后端开发中越来越重要，每个技术童鞋都有必要熟悉这个技术栈
kubernetes入门 kubernetes的核心组件 API Server API server 的核心功能是提供k8s各类资源对象(如Pod、RC、Service)的增删改查及Watch等HTTP REST接口，成为集群内各个功能模块之间数据交互和通信的中心枢纽，是整个集群的数据总线和数据中心，运行在master节点。 通常还具有以下功能。
集群管理的API入口 资源配额控制的入口 提供了完备的集群安全机制。 通常我们会通过kubectl命令与API server进行交互，提供restful API，所以说也可以通过代码方式直接调用k8s的API server。
控制器管理器(controller-manager) controller-manager作为集群内部的管理控制中心，负责集群内部的Node、Pod、Endpoint、Namespace、ServiceAccount、ResourceQuota等的管理，意为控制器，运行在master节点。
ReplicaSet Controller(副本控制器): 管理控制 pod 副本（服务集群）的数量，以使其永远与预期设定的数量保持一致。 Endpoint Controller(节点控制器): Endpoint用来表示kubernetes集群中Service对应的后端Pod副本的访问地址，Endpoint Controller则是用来生成和维护Endpoints对象的控制器，其主要负责监听Service和对应Pod副本变化。 Deployment Controller(部署控制器): Deployment中文意思为部署、调度，通过Deployment我们能操作RS（ReplicaSet） StatefulSet Controller(状态控制器): StatefulSet的出现是K8S为了解决 “有状态” 应用落地而产生的，Stateful这个单词本身就是“有状态”的意思 DaemonSet Controller(收回控制器): Daemon本身就是守护进程的意思，那么很显然DaemonSet就是K8S里实现守护进程机制的控制器 Job Controller(任务控制器): 在K8S里运行批处理任务我们用Job即可 CronJob Controller(cronjob控制器): 定时任务 调度器(scheduler) kube-scheduler意为调度器，在集群承担了"承上启下"的重要功能，“承上”指的是它负责接收 Controller -manager创建的新Pod。为其安排一个可以安置的node;“启下”指的是安置完成之后，目前Node上的kubelet服务进程接管后继续工作，负责Pod生命周期中的下半生。
kubelet 一个在集群中每个节点(node)上运行的代理。 它保证容器(containers)都 运行在 Pod 中。 kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。
kube-proxy kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务(Service) 概念的一部分。
etcd 存储数据
kubernetes的请求流程 Pod Pod可以理解为是一组功能相同的容器，装的是docker创建的容器，也就是用来封装容器的一个容器； Pod 是一个虚拟化分组，有自己的IP地址和主机名hostname，利用namespace 进行资源隔离，相当于一台独立沙箱环境； Pod 相当于一台独立主机，内部可以封装一个或多个容器(通常是一组相关的容器)，内部容器之间访问采用 localhost。 Pod可以理解为豌豆荚
Service Kubernetes Service定义了逻辑上的一组Pod的抽象，可以通过一定策略访问这个Service, 我们一般称为微服务。 Service所针对的Pods集合通常是通过选择算符(标签选择器)来确定的， Pod经常被创建和销毁，IP地址不固定，Service定义一组逻辑上的一组Pod的抽象，通过kube-proxy自动分配一个集群内部可以访问的虚IP，称为cluster IP。
在 Kubernetes 中，可以通过 Cluster Ip 来找到 Pod 的访问规则，但是 Cluster Ip 不好记啊，所以 Kuberbetes 提供了一个 CoreDns 的组件来对 Service 进行解析。 CoreDns 是一个DNS服务器，每当有Service创建时，都会在DNS服务里面增加一条记录。集群中的Pod可以通过&lt;SERVICE_NAME>.&lt;NAMESPACE_NAME>访问Service
dig codereviewapi Server: 10.96.0.10 Address: 10.96.0.10:53 Name: codereviewapi.codereview.svc.cluster.local Address: 10.111.72.52 Kubernetes Service对外暴露服务通过NodePort、LoadBalancer和ExternalName
NodePort：建立在ClusterIP类型之上，其在每个Node的IP地址的某静态端口（NodePort）暴露服务，NodePort的路由目标为ClusterIP，简单来说，NodePort类型就是在工作节点的IP地址上选择一个端口用于将集群外部的用户请求转发至目标Service的ClusterIP和Port，这种类型的Service既可如ClusterIP一样受到集群内部客户端Pod的访问，也会受到集群外部客户端通过套接字NodeIP:NodePort进行的请求；
LoadBalancer：建构在NodePort类型之上，其通过cloud provider提供的负载均衡器将服务暴露到集群外部，LoadBalancer类型的Service会指向关联至Kubernetes集群外部的某个负载均衡设备，该设备通过工作节点之上的NodePort向集群内部发送请求流量，这种Service的优势在于，能够把来自于集群外部客户端的请求调度至所有节点（或部分节点）的NodePort之上，而不是依赖于客户端自行决定连接至哪个节点，从而避免了因客户端指定的节点故障而导致的服务不可用；
ExternalName：通过将Service映射至由externalName字段的内容指定的主机名来暴露服务，此主机名需要被DNS服务解析至CNAME类型的记录。这种类型并非定义由Kubernetes集群提供的服务，而是把集群外部的某服务以DNS CNAME记录的方式映射到集群内，从而让集群内的Pod资源能够访问外部的Service的一种实现方式，这种类型的Service没有ClusterIP和NodePort，也没有标签选择器用于选择Pod资源。
Ingress Service对集群之外暴露服务的主要方式有两种：NodePort和LoadBalancer，但是这两种方式，都有一定的缺点：
NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显。
LoadBalancer的缺点是每个Service都需要一个LB，浪费，麻烦，并且需要kubernetes之外的设备的支持。
Ingress相当于一个七层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解为Ingress里面建立了诸多映射规则，Ingress Controller通过监听这些配置规则并转化为Nginx的反向代理配置，然后对外提供服务。</content></entry><entry><title>Docker常用的命令</title><url>https://lizj3624.github.io/post/docker-cmd/</url><categories><category>docker</category></categories><tags><tag>docker</tag></tags><content type="html"> 一、汇总： Docker环境信息 — docker [info|version] 容器生命周期管理 — docker [create|exec|run|start|stop|restart|kill|rm|pause|unpause] 容器操作运维 — docker [ps|inspect|top|attach|wait|export|port|rename|stat] 容器rootfs命令 — docker [commit|cp|diff] 镜像仓库 — docker [login|pull|push|search] 本地镜像管理 — docker [build|images|rmi|tag|save|import|load] 容器资源管理 — docker [volume|network] 系统日志信息 — docker [events|history|logs] 常用命令的含义：
1、docker命令介绍 docker --help 管理命令: container 管理容器 image 管理镜像 network 管理网络
命令： attach 介入到一个正在运行的容器 build 根据Dockerfile构建一个镜像 commit 根据容器的更改创建一个新的镜像 cp 在本地文件系统与容器中复制 文件/文件夹 create 创建一个新容器 exec 在容器中执行一条命令 images 列出镜像 kill 杀死一个或多个正在运行的容器
logs 取得容器的日志 pause 暂停一个或多个容器的所有进程 ps 列出所有容器 pull 拉取一个镜像或仓库到registry push 推送一个镜像或仓库到registry rename 重命名一个容器 restart 重新启动一个或多个容器 rm 删除一个或多个容器 rmi 删除一个或多个镜像 run 在一个新的容器中执行一条命令 search 在Docker Hub中搜索镜像 start 启动一个或多个已经停止运行的容器 stats 显示一个容器的实时资源占用 stop 停止一个或多个正在运行的容器 tag 为镜像创建一个新的标签 top 显示一个容器内的所有进程 unpause 恢复一个或多个容器内所有被暂停的进程
docker info #查看系统(docker)层面信息，包括管理的images, containers数等 docker version #查看docker的版本号，包括客户端、服务端、依赖的Go等 二、镜像相关 1、拉取镜像 # docker pull &lt;image> 从docker registry server 中下拉image docker pull nginx 2、查看镜像 docker images ##过滤掉中间镜像（现有镜像的父镜像） docker images -a ##列出所有的images 3、推送镜像 docker push &lt;image|repository> #推送一个image或repository到registry docker push &lt;image|repository>:TAG #同上，指定tag 4、删除镜像 docker rmi 常用参数：
-f：强制删除运行中的容器
5、创建镜像 （1）对源镜像更改后重新建立新镜像
docker commit &lt;container> [repo:tag] ##将一个container固化为一个新的image，后面的repo:tag可选 常用参数：
-m：本次提交信息
--author="" ：作者
（2）使用Dockerfile文件来构建镜像
docker build 常用参数：
-t x/y:z：指定镜像的命名空间为x，仓库为y，tag为z 6、搜索镜像 docker search nginx 7、登录远端镜像仓库 docker login --username=yourhubusername --email=youremail@company.com 8、查看镜像底层信息 docker inspect &lt;image|container> ##查看image或container的底层信息 9、镜像导入和导出 ##快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。 docker save ##保存的是镜像（image），docker export 保存的是容器（container）； docker load ##用来载入镜像包，docker import 用来载入容器包，但两者都会恢复为镜像； docker load ##不能对载入的镜像重命名，而 docker import 可以为镜像指定新名称，如： docker import ubuntu.tar merge_gt/ubuntu:v1(新名称)。 三、容器相关 1、运行容器 docker run 常用参数：
--name:为容器指定名称
-it:启动一个交互型容器，此参数为我们和容器提供了一个交互shell
-d:创建后台型容器
-restart=always:容器退出后自动重启
-restart=on-failure:x:容器退出时如果返回值是非0，就会尝试重启x次
-p x:y :主机端口：容器端口
-P：随机分配一个49000到49900的端口
-v：创建数据卷
-n :指定dns
-h : 指定容器的hostname
-e ：设置环境变量
-m :设置容器使用内存最大值
--net: 指定容器的网络连接类型，支持bridge/host/none/container
--link=x: 添加链接到另一个容器x
--expose=x: 开放端口x
这里docker create和docker run -it创建的容器都是交互型容器
2、查看正在运行的容器 docker ps 常用参数： -a：查看所有容器 -l:只列出最近创建的 -n=x:只列出最后创建的x个 -q: 只列出容器id
3、停止容器 docker stop ##方式较温柔，慢慢的停止容器的运行 docker kill ##方式简单粗暴，立即停止容器运行 docker start/stop/restart &lt;container> ##开启/停止/重启container docker start -i &lt;container> ##启动一个container并进入交互模式 4、删除容器 docker rm &lt;container...> ##删除一个或多个container docker rm `docker ps -a -q` ##删除所有的container docker ps -a -q | xargs docker rm ##同上, 删除所有的container 常用参数： -f：强制删除运行中的容器
5、查看容器日志 docker logs &lt;container> ###查看container的日志，也就是执行命令的一些输出 常用参数： -f：实时查看日志 --tail=x:查看最后x行 -t:查看日志产生的时间
6、查看容器进程 docker top 7、查看容器配置信息 docker inspect 常用参数：
-f='{{x}}'：查看x配置 8、进入容器 （1）进入交互型容器
docker attch （2）进入后台型容器
docker exec 常用参数： -it 容器id /bin/bash：进入到后台容器
9、使用docker cp将文件从本地复制到容器 docker cp index.html hardcore_torvalds:usr/share/nginx/html/ 四、dockerfile 1、docker build docker build &lt;path> ##寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image docker build -t repo[:tag] ##同上，可以指定repo和可选的tag docker build - &lt; &lt;dockerfile> ###使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image 2、常用命令 FROM命令: 既然我们是在原有的centos镜像的基础上做定制，那么我们的新镜像也一定是需要以centos这个镜像为基础的，而FROM命令则代表了这个意思，在DockerFile中，基础镜像是必须指定的，FROM指令的作用就是指定基础镜像，因此一个DockerFile中,FROM是必备的指令，而且就像java，python的import关键字一样，在DockerFile中，FROM指令必须放在第一条指令的位置
当然，这个时候可能有朋友会问了，我要是不想在其他的镜像上定制镜像怎么办呢，没问题啊，Docker 提供了scratch 这个虚拟镜像，如果你选择 FROM scratch 的话，则意味着你不以任何镜像为基础，接下来所写的指令将作为镜像的第一层开始存在，当然，在某些情况下，比如linux下静态编译的程序，运行的时候不需要操作系统提供运行时的支持，这个时候FROM scratch 是没有问题的，反而会大幅降低我们的镜像体积。
ENV指令 功能：设置环境变量
同样的，DockerFile也提供了两种格式：
ENV key value ENV key1=value1 key2=value2 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN， 还是运行时的应用，都可以直接使用这里定义的环境变量。
可以看到我们示例中使用ENV设置mypath变量之后，在下一行WORKDIR则使用到了mypath这个变量
ENV mypath /tmp ##设置环境变量 WORKDIR $mypath ###指定工作目录 WORKDIR 指令： 功能，指定工作目录
格式为：WORKDIR 工作目录路径，如果这个目录不存在的话，WORKDIR则会帮助我们创建这个目录。
设置过工作目录之后，当我们启动容器，会直接进入该工作目录
[root@8081304919c9 tmp]# RUN命令: RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令也是在定制镜像时是较为常用的指令之一。
RUN命令的格式一共有两种，分别是:
Shell格式
RUN``命令，就像直接在命令行中输入命令一样，比如RUN yum -y install vim`就是使用的这种格式
exec格式
RUN[&ldquo;可执行文件&rdquo;,&ldquo;参数1&rdquo;,&ldquo;参数2&rdquo;]，感觉就像调用函数一样
就像我们在上一篇文章中说过的那样，DockerFile中每一条指令都会建立一层，比如我们上面执行过下面这条命令
RUN yum -y install vim 执行结束之后，则调用commit提交这一层的修改，使之构成一个新的镜像，怎么样，是不是豁然开朗了呢。
同样的，Dockerfile支持Shell类的行尾添加 \的命令换行方式，以 及行首#进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。
提示：
如果使用apt方式安装的话，最后不要忘记清理掉额外产生的apt缓存文件，如果不清理的话会让我们的镜像显得非常臃肿。因为DockerFile生成一层新的镜像的时候，并不会删除上一层镜像所残留的文件。
EXPOSE指令： 功能：声明端口
格式： EXPOSE 端口1 端口2
EXPOSE 指令是声明运行时容器提供服务端口，这当然只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。这样声明主要是为了方便后期我们配置端口映射。
CMD指令： 之前介绍容器的时候曾经说过，Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD指令就是用于指定默认的容器主进程的启动命令的。
同样的，DockerFile也为我们提供了两种格式来使用CMD命令:
shell格式：CMD命令 exec 格式：CMD ["可执行文件", "参数 1", "参数 2"...] 示例中，我们使用的是第一种：
CMD /bin/bash 这条指令带来的效果就是，当我们通过run -it 启动命令的时候，容器会自动执行/bin/bash，centos默认也是CMD /bin/bash，所以当我们运行centos镜像的时候，会自动进入bash环境里面。
当然，我们也可以通过运行时指定命令的方式来体换默认的命令，比如:
docker run -it centos cat /etc/os-release 这样当我们运行镜像的时候，cat /etc/os-release就会替代默认的CMD /bin/bash输出系统的版本信息了。
如果使用shell格式的话， 实际的命令会被包装为sh -c的参数的形式进行执行。
比如：
CMD echo $HOME 在实际执行中，会将其变更为
CMD [ "sh", "-c", "echo $HOME" ] 当然还有很多初学者特别容易犯的问题，就是去启动后台服务，比如:
CMD service nginx start 这样子去用，会发现容器运行了一会就自动退出了。
我们之前不止一次的提醒过，容器不是虚拟机，容器就是进程，容器内的应用都应该以前台运行，而不是像虚拟机，物理机那样去运行后台服务，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。
怎么理解呢？想想偶像剧，容器是女主角，主进程是男主角
你走了，我也不活了（撕心裂肺大哭），大概就是这么个意思。
正如我们前面所提出的，实际上CMD service nginx start最终会被理解为：
CMD [ "sh", "-c", "service nginx start"] 在这里，我们主进程实际就是sh，当我们service nginx start执行完毕之后，那么sh自然就会退出了，主进程退出，容器自然就会相应的停止。争取的做法是直接执行nginx可执行文件，并且声明以前台的形式运行:
CMD ["nginx", "-g", "daemon off;"] 到这里，我们示例中所涉及到的命令已经讲完了，当然，这并不够，Docker中仍然有很多命令是我们使用比较频繁的，下面我们的部分作为补充，讲一下其他常用的DockerFile命令。
COPY 命令: 功能:复制文件
Docker依旧提供了两种格式供我们选择:
COPY [&ndash;chown=:] &lt;源路径>&hellip; &lt;目标路径> COPY [&ndash;chown=:] ["&lt;源路径 1>",&hellip; &ldquo;&lt;目标路径>"] 到这里大家其实会发现，Docker提供的两种格式其实都是差不多的用法，一种类似于命令行，一种则类似于函数调用。
第一种例如(将package.json拷贝到/usr/src/app/目录下):
COPY package.json /usr/src/app/ 其次，目标路径 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径 ，工作目录可以用 WORKDIR 指令来指定，如果需要改变文件所属的用户或者用户组，可以加上&ndash;chown 选项。
需要注意的是，使用 COPY 指 令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这 个特性对于镜像定制很有用。
ADD命令： ADD命令可以理解为COPY命令的高级版，格式和用法与COPY几乎一致，ADD在COPY的基础上增加了一些功能，比如源路径可以是一个URL链接，当你这么用的时候，Docker会尝试着先将该URL代表的文件下载下来，然后复制到目标目录上去，其他的则是在COPY的基础上增加了解压缩之类的操作，码字码的手疼，需要了解的朋友可以去官网查看相关的文档，这里我就不延申了。
VOLUME 定义匿名卷: 在上一篇中，我们有讲容器卷这个概念，为了防止运行时用户忘记 将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些 目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运 行，不会向容器存储层写入大量数据。
例如:
VOLUME /data 复制代码 运行时通过-v参数即可以覆盖默认的匿名卷设置。
USER 命令: 功能:指定当前用户
格式:USER 用户名:用户组
USER指令和WORKDIR相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER则是改变之后层的执行RUN, CMD以及ENTRYPOINT这类命令的身份。当然，和WORKDIR一样，USER只是帮助你切换到指定用户。
当然这个大前提是，你的User用户是事先存在好的。
3、dockerfile用例 FROM centos ##继承至centos ENV mypath /tmp ##设置环境变量 WORKDIR $mypath ##指定工作目录 RUN yum -y install vim ##执行yum命令安装vim RUN yum -y install net-tools ###执行yum命令安装net-tools EXPOSE 80 ###对外默认暴露的端口是80 CMD /bin/bash ###CMD 容器启动命令，在运行容器的时候会自动执行这行命令，比如当我们 docker run -it centos 的时候，就会直接进入bash ##然后编译该镜像 docker build -f ./DockerFile -t mycentos:1.3. -t ##新镜像名字:版本 -f ###文件 -d 文件夹 引用 dockerfile的最佳实践
docker命令</content></entry><entry><title>Docker入门与实践</title><url>https://lizj3624.github.io/post/docker-primer/</url><categories><category>docker</category></categories><tags><tag>docker</tag></tags><content type="html"> 基础入门 docker命令大全速查 docker命令大全速查
docker核心概念 容器: Container 镜像: Image 仓库: Repository 使用docker镜像 获取镜像 # docker [image] pull NAME:[TAG] # NAME是镜像的名字，TAG是标签 docker pull ubuntu:18.04 docker pull registry.hub.docker.com/ubuntu:18.04 查看镜像信息 docker image docker tag ubuntu:latest myybuntu:latest docker inspect ubuntu:18.04 docker history ubuntu:18.04 查找 docker search --filter=stars=4 nginx 删除 docker rmi myubuntu:latest 创建容器 docker commit -m "add new file" -a "Docker Newbee" a925cb40b3f0 test:0.1 cat ubuntu-18.04-x86_64-minimal.tar.gz |docker import - ubuntu:18.04 # docker file 存出和载入镜像 docker load -i ubuntu_18.04.tar docker load &lt; ubuntu_18.04.tar docker tag test:latest user/test:latest docker push user/test:latest 操作容器 ## 创建容器 docker create -it ubuntu:latest ## 启动已经创建的容器 docker start af ## 创建并启动容器 docker run ubuntu /bin/echo 'Hello workd' -d 守护 ## 停止 docker pause [contains] docker stop ce5 docker restart ce5 ## 进入容器 docker attach docker exec -it 243c32535da7 /bin/bash ## 删除 docker rm ce554267d7a4 docker数据管理 数据卷将主机操作系统的目录直接映射到容器，类型Linux的mount行为
docker volume create -d local test # -mount 选项支持三种类型的数据卷，包括 : # volume : 普通数据卷，映射到主机/ var/lib/docker/volumes 路径下; # bind:绑定数据卷，映射到主机指定路径下; # tmpfs :临时数据卷，只存在于内存中 。 docker run d P -name web mount type=bind,source=/webapp,destination=/opt/ webapp training/webapp python app.py docker run -d -P --name web -v /webapp:/opt/webapp training/webapp python app.py # 只读 ro docker run -d -P --name web -v /webapp: /opt/webapp:ro training/webapp python app.py # 数据卷容器 docker run -it -v /dbdata --name dbdata ubuntu docker run -it --volumes-from dbdata -name db1 ubuntu # 数据卷容器备份和恢复 docker run -volumes-from dbdata -v $ (pwd) :/backup - -name worker ubuntu tar cvf /backup/backup.tar /dbdata docker run -v /dbdata --name dbdata2 ubuntu /bin/bash 端口映射与容器互联 当容器中运行一些网络应用， 要让外部访问这些应用时， 可以通过-P或-p参数来指 定端口映射。当使用平(大写的)标记时， Docker会随机映射一个49000~49900的端口 到内部容器开放的网络端口:
# 本地主机的49155被映射到了容器的5000端口 docker run -d -P training/webapp python app.py # -p (小写的)则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。 支持的格式有 IP:HostPort:ContainerPort | IP::ContainerPort | HostPort:ContainerPort。 docker run -d -p 5000:5000 training/webapp python app.py docker run -d -p 5000:5000 -p 3000:80 training/webapp py thon app.py docker run -d -p 127.0.0.1::5000 training/webapp python app.py docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py # 查看端口映射 docker port nostalgic_morse 5000 docker run -d -P --name web --link db:db 扛aining/webapp py七hon app.py Dockerfile创建镜像 docker file 进阶 核心技术 基础架构 服务端 dockerd：为客户端提供RESTful API，响应来自客户端的请求，采用模块化的架构，通过专门的Engine模块来分发管理各个来自客户端的任务。 docker-proxy：是dockerd的子进程，当需要进行容器端口映射时，docker-proxy完成网络映射配置 containerd：是dockerd的子进程，提供gRPC接口响应来自dockerd的请求，对下管理runC镜像和容器环境。 containerd-shim：是containerd的子进程，为runC容器提供支持，同时作为容器内进程的根进程 runC是从docker公司开源的libcontainer项目演化而来的，目前加入OCI(Open Containers Initiative)，支持容器相关的技术栈，同时正在实现跨OS
客户端 docker命令就是客户端
镜像仓库 docker hub
命名空间 命名空间(namespace)是Linux内核的一个强大特性，为容器虚拟化的实现提供极大便利，每个容器都可以拥有自己单独的命名空间。 实现了内存、CPU、网络IO、硬盘IO、存储空间，还有文件系统、网络、PID、UID、IPC等相互隔离
进程命名空间 IPC命名空间 网络命名空间 挂载命名空间 UTS命名空间 用户命名空间 控制组 控制组(CGroups)是Linux内核的一个特性
资源限制 优先级 资源审计 隔离 控制 联合文件系统 联合文件系统(UnionFS)是一种轻量级的高性能分层文件系统，它支持将文件系统中的修改信息作为一次提交，并层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，应用看到的挂载的最终结果。是docker镜像的技术基础
Linux网络虚拟化 docker中网络接口默认是虚拟接口.docker服务启动时首先在主机上自动创建一个docker0虚拟网桥，实际上是一个Linux网桥。网桥可以理解为一个软件交换机，负责挂载其上的接口之间进行包转发。同时，Docker随机分配一个本地未占用的私有网段中的一个地址给docker0接口，比如172.17.0.0、16，掩码为255.255.0.0.，此后启动的容器的网口也会自动分配一个该网段的地址。当创建一个Docker容器的时候，同时会创建了一对veth pair互联接口。当向任一个接口发送包时，另外一个接口自动收到相同的包。互联接口的一端位于容器内，即eth0；另一端在本地并被挂载到docker0网桥，名称以veth开头。通过这种方式，主机可以与容器通信，容器之间也可以相互通信。如此一来，Docker就创建了在主机和所有容器之间一个虚拟共享网络。</content></entry><entry><title>Hugo新增评论插件</title><url>https://lizj3624.github.io/post/hugo-comment/</url><categories><category>hugo</category></categories><tags><tag>hugo-plug-in</tag></tags><content type="html"> 缘起 我通过github用hugo的hugo-theme-next模板搭建博客，但是发现评论不可用， 每次提交评论时都提示Window.fetch: https://Your WalineSerURL/comment?lang=zh-cn is not a valid UR的错误，经过一顿google查询， 发现Hugo本身不支持评论，需要通过插件支持，我用的是hugo-theme-next的主题模板，评论插件是waline
waline评论插件 waline快速上手</content></entry><entry><title>美股科技巨头2021Q4财报</title><url>https://lizj3624.github.io/post/faamg/</url><categories/><tags><tag>美股</tag><tag>财报</tag><tag>FAAMG</tag></tags><content type="html"> 2022年2月美股科技巨头(FAAMG)相继发Q4财报，财报总结如下
云计算三巨头 本季度亚马逊云(AWS)Q4营收177.8亿美金，同比增速40%，微软云(Azure)Q4营收81.97亿美金，同比增速46%，谷歌云(GCP)Q4营收55.41亿美金，同比增速45%，均略超市场预期。三家云计算厂商预计占据市场超过75%的市场份额。
图1：AWS、Google Cloud、微软Azure季度增速对比 图2：2021年三家头部云计算厂商占据全球市场75%的市场份额 FAAMG财报 苹果：收入利润均超预期，硬件需求强劲，软件收入持续快速上升。2022财年第一季度苹果公司实现营收1239亿美元，同比增长11.3%，超彭博一致预期（1191亿美元），主要来源于2021年下半年新品发布的iPhone和Mac业务。同时软件用户端量价齐升，超越市场预期。毛利率逆势上升至43.8%。下季度指引：在供应限制的挑战下，产品收入有望实现稳健的同比增长。服务预计将实现强劲的两位数增长。毛利率预计在42.5%-43.5%之间，运营支出预计为125亿-127亿美元。
微软：数字化需求强劲，公司预计下季度Azure同比增速将上升，个人PC正在结构性复兴。本季度营收517亿美元，同比增长20%，经营利润222亿美元，同比增长24%，均略超市场预期。本季度Azure收入增速46%。下季度指引：智能云业务预计营收在187.5亿到190亿美元，生产力与业务处理预计营收156亿到158.5亿美元，个人计算预计营收141.5亿到144.5亿美元。
谷歌：净利润大超预期，广告需求强劲且竞争力改善。总营收753亿美元，同比增速32%，略超市场预期。经营利润219亿，同比增长40%。三季度EPS30.69美元，大超市场预期。谷歌广告除了相对受益苹果隐私新政之外，旅游业的强劲复苏也有望带动旅游广告投放量的增加。但YouTube、谷歌云未来的调整和增长点值得关注。
亚马逊：云计算超预期，电商供应链与资本开支压力或在下季度得到一定缓解，Prime提价。公司2月3日发布四季度财报，营收略低于预期。AWS本季营收增速提升到40%。下季度指引，收入预计1120-1170亿美元，预计同比增长3%-8%。营业利润预计30-60亿美元，去年同期为89亿美元。
特斯拉：交付能力与盈利能力均略超市场预期，22年主要关注FSD能力与机器人研发。公司本季度生产交付、盈利能力仍在快速提升，总收入同比增长65%，达到177亿美元；营业利润率达到14.7%，在所有批量OEM中实现了最高的季度营业利润率；其中汽车收入同比增长71%，达到160亿美元。全年汽车收入472亿美元，同比增长73%，营业利润率12%；全年GAAP净利润55亿美元，盈利能力快速提升。从汽车生产销售来看，全年汽车总产量超93.04万台，同比增长83%，汽车交付量超93.62万台，同比增长87%。汽车收入毛利率增加3.7个百分点，达到29.3%，其背后主要驱动力在于降低成本、利用上海工厂出口销售和刺激需求。
Meta：App用户增长停滞，且苹果Att政策影响短期盈利能力，主动应变，以短视频Reels、布局元宇宙生态应对Tiktok短视频崛起的全球竞争。季度收入同比增20%达336.7亿美元，略高于彭博一致预期，圣诞季Quest2销售贡献。利润不及预期，主要原因在于苹果隐私新政、监管影响、宏观经济影响（成本上升、供应链问题），用户时长主动部分迁移至商业化程度较低的Reels，以及美元升值带来的外汇影响。经营利润126亿美元，同比下滑1.5%，经营利润率37.4%。Meta面临和Tiktok的竞争与获取年轻用户的问题，短视频是发力的主战场之一，元宇宙生态则是下一代社交的真正决胜。公司2022年1季度的收入指引在270-290亿美元区间，同比增长3%-11%。</content></entry><entry><title>50种认知偏差</title><url>https://lizj3624.github.io/post/50-cognitive-biases/</url><categories/><tags><tag>认知偏差</tag></tags><content type="html"> 前段时间埃隆.马斯克在社交网站发布50种认知偏差，建议年轻人都应该了解这些偏差，可以少走一些弯路。 国人翻译成中文，再次记录一下，有空多看看这些认知偏差
什么是“认知偏差”？ 认知偏差是人们在知觉自身、他人或外部环境时，常因自身或情境的原因使得知觉结果出现失真的现象。 典型表现有显著性偏差、生动性偏差等。 社会知觉中常见的刻板印象、晕轮效应等均为某种形式的知觉偏差。是个人知觉具有选择性的特征所致。
“认知偏差”一般可以使用认知行为疗法（CBT）进行调整。 CBT是通过改变你不合理的思维模式与行为模式，来减少你产生失调的情绪和行为，从而达到改善你心理问题的疗法。
50种认知偏差-中文版 1. 基本归因错误 Fundamental Attribution Error
我们经常根据个性或者性格来定义别人，但会用情境因素帮自己开脱。
例如：Sally上课迟到，肯定是她懒，你自己迟到，就是早上太忙乱。
2. 自私的偏见 Self-Serving Bias
失败总是有原因的，⽽成功全是靠⾃⼰。
例如：觉得得奖是因为自己工作努力，而不是靠别人帮助和运气。但考试不及格，只是因为睡眠不足而已。
3. 组内偏爱 In-Group Favoritism
我们偏爱同一个圈子的圈内人，而不是圈外人。
例如：Francis跟你一个教堂，所以你喜欢他多过Sally。
4. 从众效应 Bandwagon Effect
随着越来越多的人接受某些理念、时尚和信仰，这些理念的影响也会随之壮大。
例如：Sally觉得指尖陀螺对孩子挺好的，Francis也这么觉得。
5. 群体思维 Groupthink
希望团队保持一致与和谐，我们有时会为了减少冲突去做一些不合理的决定。
例如：Sally想买冰激凌，Francis想买T恤，所以你建议买印冰激凌图案的T恤。
6. 光环效应 Halo Effect
如果你认为一个人具有某种积极的特质，那么这种积极的印象会溢出到他的其他特质中。反之亦然。
例如：Taylor这么可爱，他肯定一点也不刻薄。
7. 道德运气 Moral Luck
由于一个好的结果，会提高人们对其道德地位的评价，反之亦然。
例如：xx赢得了xx之争，那他们比输掉的人更有德行。
8. 错误共识 False Consensus
现实中支持我们观点的人要比我们想象中的少。
例如：所有人都是这么想的！
9. 知识的诅咒 Curse of Knowledge
一旦我们知道了某件事，我们就会假设其他人也同样知道这件事。
例如：Alice是一名教师，她很难理解新同学们看事情的⻆度。
10. 聚光灯效应 Spotlight Effect
我们会高估他人对自己外表及行为举止的关注程度。
例如：Sally很担心大家会注意到她的冰激凌T恤有多丑。
11. 可用性启发法 Availability Heuristic
我们在做判断时，通常都依赖于当下脑海中出现的最直观例子。
例如：选择品牌时，你通常会选择最近看到过广告的那家。
12. 防御性归因 Defensive Attribution
一件事故中，如果目击者与受害者经历相似，他们就会更少的责怪受害者，转而去攻击加害者。反之亦然。
例如：Sally开车等绿灯时在车里玩手机被追尾。目击者Greg也会开车玩手机。所以他对撞了Sally的人大吼大叫。
13. 公正世界假说 Just-World Hypothesis
我们倾向于相信世界是公正的。因此，我们会认为不公正的事是有原因的。
例如：Sally的钱包被偷了，看，她总因为T恤的事批评Francis，遭报应了吧。
14. 朴素现实主义 Naive Realism
我们相信自己观察到的就是客观现实；而其他人则是不理性，不知情或者有偏见的。
例如：我看到了这个世界的真相，其他人都很蠢。
15. 幼稚的愤世嫉俗 Naive Cynicism
相信自己观察到的是客观事实，而其他人以自我为中心的偏见比他们实际表现出来的更多。
例如：这人对我好的原因，肯定是想从我这⾥得到点什么。
16. 弗拉效应（又名巴纳姆效应） Forer Effect (aka Barnum Effect)
我们很容易将我们的个性归结为模糊的陈述，即使它们适用于更为广泛的人。
例如：这个星座指南真的是太准了！
17. 邓宁-克鲁格效应 Dunning-Kruger Effect
你知道的越少就越自信。知道的越多就越不自信。
例如：Francis自信地向大家保证，冰淇淋里绝对没有海带，海带也没有被用于乳制品行业。
18. 锚定效应 Anchoring
我们在做决定时非常依赖第一眼看到的信息。
例如：这东西现在是原价的50%，那肯定老便宜了。
19. 自动化系统偏差 Automation Bias
我们依赖自动化系统，有时甚至过于相信，导致真正正确的决策被放弃。
例如：手机的自动纠错功能把 “its” 替换成了 “it’s”，于是你假定“it’s”就是正确的。
20. 谷歌效应（又名数码健忘症） Google Effect (aka Digital Amnesia)
我们经常会忘记在搜索引擎中很容易找到的信息。
例如：那个电影的演员叫啥来着？我都查了8次了。
21. 阻抗理论 Reactance
当⾃由受到限制时，我们会产生不快，所以会做出一些反抗的行为来释放情绪。
例如：家长越让孩子去做作业，孩子越是不愿意做。
22. 确认偏差 Confirmation Bias
我们倾向于找到并记住能证实我们看法的信息。
例如：用不完整的证据得出一个阴谋论，却忽略那些相反的论据。
23. 逆火效应 Backfire Effect
人的一个错误的认知被新信息推翻时，新信息与人原本的看法不符，反而会加深人对原本错误认知的信任。
例如：相信阴谋论的人会认为，新出现的证据都是伪造用来掩盖阴谋论的。
24. 第三人称效应 Third-Person Effect
我们会认为媒体对他人的影响比对我们自己更大。
例如：你显然是被媒体洗脑了。
25. 信念偏差 Belief Bias
我们判断一个论点的⼒量，不是根据它支持结论的力度，而是根据我们自己认为结论的可信度。
例如：Sally说她也支持你那个阴谋论，但她没有说出什么证据来。
26. 可获性层叠 Availability Cascade
因为我们对融入社会的需要，越被公开和重复讨论的事情，我们越会相信其真实性。
例如：糖果里藏了剃须刀片的故事广为流传，最终许多美国人不再在万圣节时提供自制糖果。
27. 衰落主义 Declinism
我们倾向于将过去浪漫化，并消极地看待未来，认为社会/机构总体上正在衰退。
例如：在我们的孩童时代，孩子更懂得尊重！
28. 现状偏见 Status Quo Bias
我们倾向于保持不变，即使是有利的变化也被认为是一种损失
例如：即使某APP侵犯了Sally的隐私，她也不愿意换另一个这方面做得更好的试试。
29. 沉没成本谬误（又名承诺升级） Sunk Cost Fallacy (aka Escalation of Commitment)
即使面临失败的结果，人们会因为前期的投入，会在这个注定失败的事情上继续投入。
例如：“投入1分钱，就会再投1块钱！”（一不做，二不休）
30. 赌徒谬误 Gambler&rsquo;s Fallacy
认为某个事件未来的可能性会受到过去事件的影响。
例如：猜硬币已经输了9次了，下次应该能猜中。
31. 零风险偏差 Zero-Risk Bias
我们更愿意将小风险降低到零，即使我们可以通过另一种选择来降低整体风险。
例如：“你应该买个保险服务”
32. 框架效应 Framing Effect
人们对一个客观上相同问题的不同描述导致了不同的决策判断。
例如：候选人获得45%的支持率将大获全胜；候选人获得45%的支持率让全国失望；
33. 刻板印象 Stereotyping
人们普遍认为，尽管没有关于个人的信息，但一个群体的成员将具有某些相同的特征。
例如：那个留着精致小胡子的人肯定是个嬉皮士，估计还收集了一些黑胶唱片。
34. 外群体同质性偏差 Outgroup Homogeneity Bias
人们认为圈外人千篇一律，而自己圈子里的人各个不同。
例如：Alice不打游戏，她认为玩游戏的人都一样。
35. 权威偏见 Authority Bias
我们信任权威人物的意见，并经常受其影响。
例如：专家说这个可以这么做。
36. 安慰剂效应 Placebo Effect
如果我们相信某种治疗会奏效，它通常会产生很小的生理效应。
例如：Alice服用了安慰剂来止痛，结果疼痛真的减轻了。
37. 幸存者偏差 Survivorship Bias
我们看到的往往是幸存者的故事，因为未幸存者已无法发声。而我们很容易把看到的当作全部。
例如：看到返航的战斗机机翼弹孔最多，得出战斗机机翼是被击中最多的部位。是事实被击中发动机的飞机已经回不来了。
38. 精神活动过速 Tachypsychia
我们对时间的看法取决于创伤、吸毒和体力消耗。
例如：当差点被汽车撞到的时候，时间都慢下来了。
39. 琐碎法则（又名自行车棚效应） Law of Triviality (aka &ldquo;Bike-Shedding&rdquo;)
人们会对琐碎的问题给予不成比例的重视，同时又避免面对复杂的问题。
例如：一个地方市政府花费了大量的时间去讨论自行车道和自行车棚的问题，而不是想办法帮助无家可归的人。
40. 蔡格尼克记忆效应 Zeigarnik Effect
比起已完成的任务，人们更容易记住未完成的任务。
例如：Greg因任务清单上还没完成的一个任务而沮丧。
41. 宜家效应 IKIA Effect
人们更看重自己参与创造的东西。
例如：“你难道不爱这个花了我20美元的茶壶吗？它上面的涂绘可是我自己亲笔画的！”
42. 本·富兰克林效应 Ben Franklin Effect
如果我们已经帮了别人一个忙，那么我们更有可能帮他另一个忙。
例如：Greg给Francis借了一支钢笔，等Francis又向Greg借5元钱时，Greg很爽快的就借了。
43. 旁观者效应 Bystander Effect
周围的人越多，我们帮助受害者的可能性就越小。
例如：当有人在斗殴中受伤时，围观的那群学生里没人去打报警电话。
44. 暗示感受性 Suggestibility
我们，尤其是儿童，有时会将提问者建议的想法误认为是记忆。
例如：“你从沙发上摔下来是在你妈妈打你之前还是之后？”
45. 虚假记忆 False Memory
我们会把想象误以为是真实的记忆。
例如：Greg确定Sally说了一个关于菠萝的笑话，但这个笑话其实是他自己想到的。
46. 潜隐记忆 Cryptomnesia
我们会将真实的记忆误认为是想象。
例如：Greg以为去过墓地是他做的一个梦，实际上他真的去过墓地。
47. 集群错觉 Cluster Illusion
我们在随机数据中发现模式和规律。
例如：“你看那个云彩像不像你家的猫？”
48. 悲观偏见 Pessimism Bias
我们有时会高估坏结果的概率。
例如：水只剩下半杯了，啥都不会变好了。
49. 乐观偏见 Optimism Bias
我们有时对好的结果过于乐观
例如：水还有半杯呢，一切都会好起来的。
50. 盲点偏见 Blind Spot Bias
人们不认为自己有偏见，还会觉得别人比自己更偏激。
例如：“我没有偏见！”
50种认知偏差-英文版 引用原文</content></entry><entry><title>查理芒格: 如何才能度过幸福且有钱的一生</title><url>https://lizj3624.github.io/post/charlie-munger-usc-law-commencement-speech-2007/</url><categories/><tags><tag>芒格</tag><tag>社科</tag></tags><content type="html"> 查理·芒格(Charlie Munger)于2007年5月在南加州法学院毕业典礼上的演讲。 演讲实录-中英文 芒格学院翻译的中文版本
查理·芒格
演讲要点： 1、要得到你想要的某样东西，最可靠的办法是让你自己配得上它。
2、必须拥有跨学科的心态，才能高效而成熟地生活。
3、摆脱自私以及偏见、嫉妒、怨憎和自怜。每当发现自己产生了自怜的情绪，不管是什么原因，哪怕由于自己的孩子患上癌症即将死去,你也要想到，自怜是于事无补的。
4、如果你真的想要在某个领域做得很出色，那么你必须对它有强烈的兴趣，也一定要非常勤奋。
5、要拥有自己真正的能力，而不是鹦鹉学舌的知识。
以下是演讲正文： 你们当中肯定有许多人会觉得奇怪：这么老还能来演讲？嗯，答案很明显：他还没有死。
我已经把今天演讲的几个要点写了下来，下面就来介绍那些对我来说最有用的道理和态度。我并不认为它们对每个人而言都是完美的，但我认为它们之中有许多具有普遍价值，也有许多是「屡试不爽」的道理。
我非常幸运，很小的时候就明白了这样一个道理：要得到你想要的某样东西，最可靠的办法是让你自己配得上它。这是一个十分简单的道理，是黄金法则。
己所不欲，勿施于人 你们要学会己所不欲，勿施于人。总的来说，拥有这种精神的人在生活中能够赢得许多东西，他们赢得的不止是金钱和名誉。还赢得尊敬，理所当然地赢得与他们打交道的人的信任。能够赢得别人的信任是非常快乐的事情。
有的时候你们会发现有些彻头彻尾的恶棍死的时候既富裕又有名，但是周围绝大多数人都认为他们死有余辜。如果教堂里满是参加葬礼的人，其中大多数人去那里是为了庆祝这个小子终于死了。
这让我想起了一个故事：有一个这样的混蛋死掉了，神父说「有人愿意站出来，对死者说点好话吗？」没有人站出来，好长时间没有人站出来，最后有个人站了出来，他说「好吧，他的兄弟更糟糕」。
这不是你们想要得到的下场，以这样的葬礼告终的生活，不是你们想要的生活。
毛姆自传体小说：《人性的枷锁》
仰慕是爱的基础 我很小就明白的第二个道理是，正确的爱应该以仰慕为基础，而且我们应该去爱那些对我们有教育意义的先贤。我懂得这个道理且一辈子都在实践它。萨默赛特·毛姆（ Somerset Maugham ）在他的小说《人性的枷锁》中描绘的爱是一种病态的爱，那是一种病，如果你们发现自己有这种病，应该赶快把它治好。
坚持终身学习 有一个道理非常重要，那就是你们必须坚持终身学习。如果不终身学习，你们将不会取得很高的成就。光靠已有的知识，你们在生活中走不了多远。离开这里以后，你们还得继续学习，这样才能在生活中走得更远。
让伯克希尔·哈撒韦在这一个十年中赚到许多钱的方法，在下一个十年未必还能那么管用，所以沃伦·巴菲特不得不成为一部不断学习的机器。
层次较低的生活也有同样的要求，我不断地看到有些人在生活中越过越好，他们不是最聪明的，甚至不是最勤奋的，但他们是学习机器。他们每天夜里睡觉时，都比那天早晨聪明一点点。孩子们，这种习惯对你们很有帮助，特别是在你们还有很长的路要走的时候。
阿尔弗雷德·诺斯·怀特海曾经说过一句很正确的话，他说只有当人类「发明了发明的方法」之后，人类社会才能快速地发展。他指的是人均 GDP 的巨大增长和其他许多我们今天已经习以为常的好东西。人类社会在几百年前才出现了大发展，在那之前，每个世纪的发展几乎等于零。
人类社会只有发明了发明的方法之后才能发展，同样的道理，你们只有学习了学习的方法之后才能进步。
我非常幸运。在就读哈佛法学院之前就已经学会了学习的方法。在我这漫长的一生中，没有什么比持续学习对我的帮助更大。再拿沃伦·巴菲特来说，如果你们拿着计时器观察他，会发现他醒着的时候有一半时间是在看书，他把剩下的时间大部分用来跟一些非常有才干的人进行一对一的交谈。有时候是打电话，有时候是当面，那些都是他信任且信任他的人。仔细观察的话，沃伦很像个学究，虽然他在世俗生活中非常成功。
学习机器巴菲特
跨学科学习的重要性 另一个对我非常有用的道理是我当年在法学院学到的。那时有位爱开玩笑的教授说：「什么是法律头脑？如果有两件事交织在一起，相互之间有影响，你努力只考虑其中一件，而完全不顾另一件，以为这种思考方式既实用又可行的头脑就是法律头脑。」我知道他是在说反话，他说的那种「法律」方法是很荒唐的。
这给了我很大的启发，因为它促使我去学习各学科中所有的重要道理，这样我就不会成为那位教授所描绘的蠢货。因为真正重要的大道理占每个学科 95% 的份量，所以对我而言，从所有的学科吸取我所需要的 95% 的知识，并将它们变成我思维习惯的一部分，也不是很难的事情。
当然，掌握了这些道理后，你们必须通过实践去使用它们。这就像钢琴演奏家，如果不持续练习，就不可能弹得很好。所以我这辈子不断地实践那种跨学科的方法。
这种习惯帮了我很多忙，它让生活更有乐趣，让我能做更多的事情，让我变得更有建设性，让我变得非常富有，而这无法用天分来解释。我的思维习惯只要得到正确的实践，真的很有帮助。
但这种习惯也会带来危险，因为它太有用了，如果你们使用它，当你们和其他学科的专家（甚至是你们的老板），能够轻而易举地伤害你们。你们会常常发现，原来你们的知识比你老板更丰富，更能够解决他所遇到的问题。当他束手无策的时候，你们有时会知道正确的答案。
隐藏睿智 遇到这样的情况是非常危险的，因为你们的正确让有身份有地位的人觉得没面子，但我还没有找到避免受这个严重问题而伤害的完美方法。
尽管我年轻时扑克牌玩得很好，但在我认为我知道的比上级多的时候，我不太擅长掩饰自己的想法，没有很谨慎地去努力掩饰自己的想法，所以我总是得罪人。
现在人们通常把我当成一个行将就木的没有恶意的古怪老头，但在从前，我有过一段很艰难的日子。我建议你们不要学我，最好学会隐藏你们的睿智。
我有个同事，他从法学院毕业时成绩是全班第一名，曾在美国最高法院工作过，年轻时当过律师，当时他总是表现出见多识广的样子。有一天，他上级的高级合伙人把他叫进办公室，对他说：「听好了，查克，我要向你解释一些事情，你的工作和职责是让客户认为他是房间里最聪明的人。如果你完成了这项任务之后还有多余的精力，应该用它来让你的高级合伙人显得像是房间里第二聪明的人。只有履行了这两条义务之后，你才可以表现你自己。」
伏尔泰：如果有权有势的人错了，
而你是对的，那你就危险了
人们必须拥有跨学科的心态，才能高效而成熟地生活。在这里，我想引用古代最伟大的律师马尔库斯·图鲁斯·西塞罗的一个重要思想。西塞罗有句话很著名，他说，如果一个人不知道他出生之前发生过什么事情，在生活中就会像一个无知的孩童。
这个道理非常正确，西塞罗正确地嘲笑了那些愚蠢得对历史一无所知的人。但如果你们将西塞罗这句话推而广之，我认为你们应该这么做：除了历史之外，还有许多东西是人们必须了解的。
所谓的许多东西就是所有学科的重要思想。但如果你对一种知识死记硬背，以便能在考试中取得好成绩，这种知识对你们不会有太大的帮助。你们必须掌握许多知识，让它们在你们的头脑中形成一个思维框架，在随后的日子里能自动地运用它们。
如果你们能够做到这一点，我郑重地向你们保证，总有一天你们会在不知不觉中意识到：「我已经成为我的同龄人中最有效率的人之一」。与之相反，如果不努力去实践这种跨学科的方法，你们中的许多最聪明的人只会取得中等成就，甚至生活在阴影中。
《西塞罗发现阿基米德之墓》
历史是时代的见证、真理的火炬
记忆的生命、生活的老师和古人的使者
逆向思维 我发现的另外一个道理蕴含在麦卡弗雷院长刚才讲过的故事中，故事里的乡下人说：「要知道我会死在哪里就好啦，我将永远不去那个地方。」这乡下人说的话虽然听起来很荒唐，却蕴含着一个深刻的道理。对于复杂的适应系统以及人类的大脑而言，如果采用逆向思考，问题往往会变得更容易解决。如果你们把问题反过来思考，通常就能够想得更加清楚。
例如，如果你们想要帮助印度，应该考虑的问题不是「我要怎样才能帮助印度？」与之相反，你们应该问：「我要怎样才能损害印度？」你们应该找到能对印度造成最大损害的事情，然后避免去做它。
也许从逻辑上来看两种方法是一样的，但那些精通代数的人知道，如果问题很难解决，利用反向证明往往就能迎刃而解。生活的情况跟代数一样，逆向思考能够帮助你们解决正面思考无法处理的问题。
让我现在就来使用一点逆向思考。什么会让我们在生活中失败呢？我们应该避免什么呢？有些答案很简单，例如，懒惰和言而无信会让我们在生活中失败。如果你们言而无信，就算有再多的优点，也无法避免悲惨的下场。所以你们应该养成言出必行的习惯，懒惰和言而无信是显然要避免的。
代数之父花拉子米
数学思维让很多问题不再是问题
避免极端意识形态 要避免极端的意识形态，因为它会让人们丧失理智。年轻人特别容易陷入强烈而愚蠢的意识形态中，而且永远走不出来。当你们宣布自己是某个类似邪教团体的忠实成员，并开始倡导该团体的意识形态时，这样你们的头脑就会坏掉，而且有时候是以惊人的速度坏掉。
我有一条「铁律」，它帮助我在偏向于支持某种强烈的意识形态时保持清醒。我觉得我没资格拥有一种观点，除非我能比我的对手更好地反驳我的立场。我认为我只有在达到这个境界时才有资格发表意见。
我的做法对大多数人而言，可能太难了，但希望对我来说它永远不会变得太难。这种别陷入极端意识形态的方法，在生活中是非常非常重要的，如果你们想要成为明智的人，严重的意识形态很有可能会导致事与愿违。
前苏联宣传画 | 警惕自我思想被人操纵
消除"自我服务偏好"和自怜 有一种叫做「自我服务偏好」的心理因素也经常导致人们做傻事，它往往是潜意识的，所有人都难免受其影响。你们认为「自我」有资格去做它想做的事情，例如，透支收入来满足它的需求，那有什么不好呢？
从前有一个人，他是全世界最著名的作曲家，可是他大部分时间过得非常悲惨，原因之一就是他总是透支他的收入。那位作曲家叫做莫扎特。连莫扎特都无法摆脱这种愚蠢行为的毒害，我觉得你们更不应该去尝试它。
总的来说，嫉妒、怨憎、仇恨和自怜都是灾难性的思想状态。过度自怜可以让人近乎偏执，偏执是最难逆转的东西之一，你们不要陷入自怜的情绪中。
我有个朋友，他随身携带一叠厚厚的卡片，每当有人说了自怜的话，他就会慢慢地、夸张地掏出那一叠卡片，将最上面那张交给说话的人。卡片上写着「你的故事让我很感动，我从来没有听过有人像你这么倒霉。」
每当你们发现自己产生了自怜的情绪，不管是什么原因，哪怕由于自己的孩子患上癌症即将死去。你们也要想到，自怜是于事无补的。这样的时候，你们要送给自己一张我朋友的卡片。自怜总是会产生负面影响，它是一种错误的思维方式。如果你们能够避开它，你们的优势就远远大于其他人。
你们当然也要在自己的思维习惯中消除自我服务的偏好，别以为对你们有利的就是对整个社会有利的，也别根据这种自我中心的潜意识倾向来为你们愚蠢或邪恶的行为辩解，那是一种可怕的思考方式。你们要让自己摆脱这种心理，因为你们想成为智者而不是傻瓜，想做好人而不是坏蛋。
你们必须在自己的认知行动中，允许别人拥有自我服务的偏好。因为大多数人无法非常成功地清除这种心理，人性就是这样。如果你们不能容忍别人在行动中表现出自我服务的偏好，那么你们又是傻瓜。
正确的说服技巧是本杰明·富兰克林指出的那种，他说：「如果你想要说服别人，要诉诸利益，而非诉诸理性。」你们应该多多诉诸利益，而不是理性，即使是当你们的动机很高尚的时候。
富兰克林：如果你想要说服别人
要诉诸利益，而非诉诸理性
远离变态的激励机制 应该避免的事是受到变态的激励机制的驱动。你们不要处在一个你们表现得越愚蠢或者越糟糕，它就提供越多回报的变态激励系统之中，变态的激励机制具有控制人类行为的强大力量，人们应该避免受它影响。
变态的工作关系也是应该避免的，你们要特别避免在你们不崇敬或者不想像他一样的人手下干活，那是很危险的。所有人在某种程度上都受到权威人物的控制，尤其是那些为我们提供回报的权威人物。
要正确地应对这种危险，必须同时拥有才华和决心。在我年轻的时候，我的办法是找出我尊敬的人，然后想办法调到他手下去。总之，在你们正确地仰慕的人手下工作，在生活中取得的成就将会更加令人满意。
养成保持公正的习惯 养成一些让你能保持客观公正的习惯。我们都记得达尔文特别留意相反的证据，尤其是他证伪的是某种他信奉和热爱的理论时。如果你们想要在思考的时候尽量少犯错误，就需要这样的习惯。
人们还需要养成核对检查清单的习惯，核对检查清单能避免很多错误，不仅仅对飞行员来说是如此。你们不应该光是掌握广泛的基础知识，而是应该把它们在头脑中列成一张清单，然后再加以使用。没有其他方法能取得相同的效果。
达尔文 | 关注正确，更关注证伪
不平等最大化的奇效 另外一个我认为很重要的道理就是，将不平等最大化通常能够收到奇效。这句话是什么意思呢？约翰·伍登（ John Wooden ）提供了一个示范性的例子。伍登曾经是世界上最优秀的篮球教练。他对五个水平较低的球员说：「你们不会得到上场的时间，你们是陪练。」
比赛几乎都是那七个水平较高的球员在打的。这七个水平高的球员学到了更多，别忘了学习机器的重要性 —— 因为他们独享了所有的比赛时间。在他采用非平等主义的方法时，伍登比从前赢得了更多的比赛。
我认为生活就像比赛也充满了竞争，我们要让那些最有能力和最愿意成为学习机器的人发挥最大的作用。如果你们想要获得非常高的成就，你们就必须成为那样的人。你们不希望在 50 个轮流做手术的医生中，抓阄抽一个来给你们的孩子做脑外科手术。
约翰·伍登 | 掌声属于获胜的那方
避免鹦鹉学舌的技巧 我经常讲一个有关马克斯·普朗克的笑话。
普朗克获得诺贝尔奖之后，到德国各地作演讲，每次讲的内容大同小异，都是关于新的量子物理理论的，时间一久，他的司机记住了讲座的内容。司机说：「普朗克教授，我们老这样也挺无聊的，不如这样吧，到慕尼黑让我来讲，你戴着我的司机帽子坐在前排，你说呢？」
普朗克说：「好啊。」于是司机走上讲台，就量子物理发表了一通长篇大论。后来有个物理学教授站起来，提了一个非常难的问题。演讲的司机说：「哇，我真没想到，我会在慕尼黑这么先进的城市，遇到这么简单的问题。我想请我的司机来回答。」
讲这个故事，并不是为了表扬主角很机敏。我认为这个世界的知识可以分为两种：一种是普朗克知识，它属于那种真正懂的人。他们付出了努力，他们拥有那种能力。另外一种是司机知识。他们掌握了鹦鹉学舌的技巧；他们可能有漂亮的头发；他们的声音通常很动听；他们给人留下深刻的印象。
但其实他们拥有的是伪装成真实知识的司机知识。如果你们在生活中想努力成为拥有普朗克知识的人，而避免成为拥有司机知识的人，你们将遇到这个问题。到时会有许多巨大的势力与你们作对。
普朗克 | 鹦鹉学舌是技巧，而不是知识
培养兴趣，保持勤奋 如果你们真的想要在某个领域做得很出色，那么你们必须对它有强烈的兴趣。我可以强迫自己把许多事情做得相当好，但我无法将我没有强烈兴趣的事情做得非常出色。从某种程度上来讲，你们也跟我差不多。所以如果有机会的话，你们要想办法去做那些你们有强烈兴趣的事情。
还有就是，你们一定要非常勤奋才行。我非常喜欢勤奋的人。我这辈子遇到的合伙人都极其勤奋。我想我之所以能够和他们合伙，部分原因在于我努力做到配得起他们，部分原因在于我很精明地选择了他们，还有部分原因是我运气好。
我早期的生意上曾经有过两位合伙人，他们俩在大萧条期间合资成立了一家建筑设计施工公司，达成了很简单的协议：「如果我们没有完成对客户的承诺，我们俩要每天工作 14 个小时，每星期工作 7 天，直到完成为止。」不用说你们也知道啦，这家公司做得很成功。我那两位合伙人广受尊敬。他们这种简单的老派观念几乎肯定能够提供一个很好的结果。
正视生活中的不幸 你们在生活中可能会遭到沉重的打击，不公平的打击。有些人能挺过去，有些人不能。我认为爱比克泰德（ Epictetus ）的态度能够引导人们作出正确的反应。他认为生活中的每一次不幸，无论多么倒霉，都是一个锻炼的机会。他认为每一次不幸都是吸取教训的良机。
人们不应该在自怜中沉沦，而是应该利用每次打击来提高自我。他的观点是非常正确的，影响了最优秀的罗马帝国皇帝马库斯·奥勒留（ Marcus Aurelius ），以及随后许多个世纪里许许多多其他的人。
你们很可能会说：「谁会在生活中整天期待麻烦的到来啊？」其实我就是这样的。在这漫长的一生中，我一直都在期待麻烦的到来。现在我已经 84 岁啦。就像爱比克泰德，我也拥有一种蒙受恩宠的生活。我总是期待麻烦的到来，准备好麻烦来临时如何对付它，这并没有让我感到不快乐。这根本对我没有任何害处，实际上，这对我有很大的帮助。
爱比克泰德 | 自怜无用
避免官僚主义，保持信任 由于在你们将要从事的行业中有大量的程序和繁文缛节，最后一个我想要告诉你们的道理是，复杂的官僚程序不是文明社会的最好制度。最好的制度是一张无缝的、非官僚的信任之网。没有太多稀奇古怪的程序。
只有一群可靠的人，他们彼此之间有正确的信任。那是玛约医疗中心手术室的运作方式。如果那里的医生像律师那样，设立许多像法律程序那么繁琐的规矩，更多的病人会死于非命。
所以当你们成为律师的时候，永远别忘记，虽然你们在工作中要遵守程序，但你不用总是被程序牵着鼻子走。你们在生活中应该追求的是尽可能地培养一张无缝的信任之网。如果你们拟定的婚姻协议书长达 47 页，那么我建议你们这婚还是不结为妙。
好啦，在毕业典礼上讲这么多已经够啦。我希望这些老人的废话对你们来说是有用的。最后，我想用约翰·班扬的巨作《天路历程》中那位真理剑客年老之后唯一可能说出的话来结束这次演讲：「我的剑传给能挥舞它的人」。</content></entry><entry><title>美股动态及各国宏观数据</title><url>https://lizj3624.github.io/post/stock-index/</url><categories/><tags><tag>美股</tag><tag>数据</tag></tags><content type="html"> 实时查看美股动态数据，实时查看各国宏观数据
新浪美股实时行情 新浪美股实时行情
新浪美股实时行情-纳斯达克交易所
历年美股市值总量
全球股指、期货、大宗商品 全球股指期货动态一览
英文财经全球金融市场动态
全球宏观 财经M平方-全球宏观</content></entry><entry><title>Cloudflare 公布 2021 年第四季度和财年财务业绩</title><url>https://lizj3624.github.io/post/cloudflare-2021-q4/</url><categories/><tags><tag>cloudflare</tag><tag>财报</tag></tags><content type="html"> 2022年2月10号盘后，Cloudflare发布了Q4财报和全年财报，信息如下
Cloudflare 2021年Q4财报亮点 第四季度收入总计 1.936 亿美元，同比增长 54%；2021财年收入总计6.564亿美元，同比增长52% 在大型企业客户持续增长的推动下，创纪录的美元净留存率为 125%，同比增长 600 个基点 第四季度实现创纪录的经营现金流和正的自由现金流；经营现金流为 4060 万美元，占总收入的 21%，自由现金流为 860 万美元，占总收入的 4% 2021财年第四季度财务摘要 收入：总收入为 1.936 亿美元，同比增长 54%。 毛利润：GAAP 毛利润为 1.511 亿美元或 78.0% 毛利率，而 2020 年第四季度为 9690 万美元或 76.9%。非 GAAP 毛利润为 1.533 亿美元或 79.2% 毛利率，而 9830 万美元，或78.1%，在 2020 年第四季度。 营业收入（亏损）：2020 年第四季度，GAAP 运营亏损为 4110 万美元，占总收入的 21.2%，而 2470 万美元，占总收入的 19.6%。非 GAAP 运营收入为 220 万美元，或占总收入的 1.2%，而 2020 年第四季度的运营亏损为 550 万美元，占总收入的 4.3%。 净收入（亏损）：GAAP 净亏损为 7750 万美元，而 2020 年第四季度为 3400 万美元。GAAP 每股基本和稀释后净亏损为 0.24 美元，而 2020 年第四季度为 0.11 美元。非 GAAP 净收入为10 万美元，而 2020 年第四季度非 GAAP 净亏损为 740 万美元。非 GAAP 每股摊薄净收益为 0.00 美元，而 2020 年第四季度非 GAAP 每股净亏损为 0.02 美元。 现金流：经营活动产生的净现金流为 4060 万美元，而 2020 年第四季度为负 880 万美元。自由现金流为 860 万美元，占总收入的 4%，而负2350 万美元，占总收入的 19%收入，在 2020 年第四季度。 截至 2021 年 12 月 31 日，现金、现金等价物和可供出售证券为 18.218 亿美元。 2021 年全年财务摘要 收入：总收入为 6.564 亿美元，同比增长 52%。 毛利润：美国通用会计准则毛利润为 5.093 亿美元或 77.6% 毛利率，而 2020 财年为 3.30 亿美元或 76.6%。非美国通用会计准则毛利润为 5.159 亿美元，或 78.6% 毛利率，而 3.346 亿美元或 77.6% %，在 2020 财年。 运营亏损： 2020 财年，GAAP 运营亏损为 1.277 亿美元，占总收入的 19.5%，而 2020 财年为 1.068 亿美元，占总收入的 24.8%。非 GAAP 运营亏损为 700 万美元，占总收入的 1.1%，相比之下，2020 财年为 3390 万美元，占总收入的 7.9%。 净亏损：GAAP 净亏损为 2.603 亿美元，而 2020 财年为 1.194 亿美元。GAAP 每股净亏损为 0.83 美元，而 2020 财年为 0.40 美元。非 GAAP 净亏损为 1510 万美元，而 2020 财年为 3510 万美元。 GAAP 每股净亏损为 0.05 美元，而 2020 财年为 0.12 美元。 现金流：经营活动产生的净现金流为 6460 万美元，而 2020 财年为负 1710 万美元。自由现金流为负 4310 万美元，占总收入的 7%，而负9210 万美元，占总收入的 21%， 2020财年。 财务展望 由于持续的 COVID-19 大流行，以下有关我们财务前景的前瞻性陈述受到很大的不确定性，反映了我们截至 2022 年 2 月 10 日关于大流行对我们运营的影响的估计，并且高度依赖于我们可能无法预测或控制的许多因素，其中包括：大流行的持续时间、传播范围和严重程度；政府和企业为应对这一流行病而采取的行动及其对我们的客户、供应商和合作伙伴的影响；在全球范围内接种 COVID-19 疫苗的时机以及这些疫苗的长期疗效；大流行对全球和区域经济以及总体经济活动的影响；我们在受影响地区继续运营的能力；
对于 2022 财年第一季度，我们预计： 总收入为 2.05 至 2.06 亿美元 Non-GAAP 运营收入为 0.5 至 150 万美元 Non-GAAP 每股净收益为 0.00 美元至 0.01 美元，使用约 3.48 亿股的加权平均已发行普通股 对于 2022 财年全年，我们预计： 总收入为 9.27 至 9.31 亿美元 Non-GAAP 运营收入为 10.0 至 1400 万美元 Non-GAAP 每股净收益为 0.03 至 0.04 美元，使用约 3.52 亿股的加权平均已发行普通股</content></entry><entry><title>中文浏览国外社交媒体热点(Buzzing.cc)</title><url>https://lizj3624.github.io/post/buzzing/</url><categories/><tags><tag>buzz</tag><tag>国外论坛</tag></tags><content type="html"> 英文不太好，一直想找翻译国外媒体热点的网站，今天终于找到了buzzing.cc
中文浏览国外社交媒体热点 Buzzing 适合：
想要了解世界（主要是英文世界）正在发生什么的人 有一定的英语基础，但是无法流畅阅读 想要提升英文阅读量，但是找不到感兴趣的读物 注重阅读体验，喜欢简约的排版 热点预览-英文版 热点预览</content></entry><entry><title>金融炼金术(The Alchemy of Finance)</title><url>https://lizj3624.github.io/post/the-alchemy-of-finance/</url><categories/><tags><tag>金融</tag><tag>读书</tag></tags><content type="html"> 最近在看索罗斯的《金融炼金术》再次做一下读书笔记以及自己的体悟
反身性理论(theory of reflexivity)的概念
反身性的概念其实很简单：在任何包含有思维参与者的情景中，参与者的思想和现实情况之间存在着一种相互影响的关系。 一方面思考者试图去了解真实的情况，另一方面他们试图获得一个他们想象中的结果。这两种过程起到的作用相反：在求 知的过程中现实是已知量，然而在参与的过程中，参与者的思想成为了已知量。在提出哪些是已知的而哪些是未知的时候，这 两种作用会相互干涉。我将这种两个作用间的相互干涉称之为"反身性"。反身性导致参与者对于现实的理解是不完美的，同时 参与者的行为也会产生他们无法预知的后果。
那种觉得市场永远能够做出正确决定的幻觉是建立在参与过程和认知过程间的反身性互动上的。事实上，市场总是错误的， 他的趋势体现在膨胀期的自我满足以及衰退期的自我瓦解。因此只有处在转折点时流行倾向才会被证明是错的。
人类不确定性原则
人类不确定性原则认为人们对于他们生活的世界的认知是不可能同时满足真实性、完整性和连贯性的。在人们的思维受到 现实限制的情况下，思维是不足以做出完美的决策的；而当思维干预了决策的情况下，思维就无法控制现实的走向。
人类不确定性原则与海森堡测不准原理有很多相似之处，海森堡测不准原理认为量子粒子的位置和动量不可能同时被测出。
索罗斯将他提出的人类不确定性原则跟量子力学的海森堡测不准原理对比，看来索罗斯对量子力学了解不少，难道他的量子 基金名称也是由此来的，哈哈。
历史的鞋带理论
我们更多地关注结果与预期之间的差别。结果会受到预期的影响，但是不会被预期所决定。它们之间存在一个双向的反馈循环： 认知过程是从结果到预期，而参与过程是从预期到结果。两个过程持续地向不同方向起作用。因果关系的方向并不是从一个结果 传到下一个，它交叉往复与结果和预期之间，反之亦然。我称之为"历史的鞋带理论"</content></entry><entry><title>美国上市公司总市值已近50万亿美金</title><url>https://lizj3624.github.io/post/us-stock-cap/</url><categories/><tags><tag>宏观</tag><tag>美股</tag></tags><content type="html"> 根据Siblis Research 的数据显示：
1、2021年9月，在纽交所、纳斯达克、美国柜台交易市场上市的美国公司总市值为48.6万亿美金，美国前500上市公司市值为38.4万亿美金，美国2020年GDP才21万亿美金。
2、美国公司在2000年初经历了互联网泡沫，市值连跌几年；2008年又经历次贷危机，市值大幅下降；随后十几年，美国公司市值基本都是年年增长。
3、虽然去年美国股市在疫情期间经历暴跌，多次熔断，但随后几个月信心很快恢复，2020年美国公司总市值还同比增加20.1%。随后美国股市屡创新高，截止今年9月份，美国公司市值已经同比上涨19.2%。
4、虽然美国公司市值不断上涨，但在美国上市的中概股却是惨不忍睹，阿里巴巴因为反垄断和蚂蚁金服事件市值已经下跌一半，教育行业由于双减政策都经历暴跌，市值十不存一，其它中概股也都有大幅度下跌。
5、美国最近十几年从移动互联网中获利最多，苹果、亚马逊、谷歌、facebook、微软不断发展，覆盖用户越来越广，对全球的影响不断加强，从全世界各地赚了太多的钱。
6、美国五大科技巨头当前市值近10万亿美金，占美国公司总市值超20%，从次贷危机以来，这五家科技巨头市值已上涨几十倍甚至上百倍，带动美国公司市值增长。
引用原文</content></entry><entry><title>Markdown语法手册</title><url>https://lizj3624.github.io/post/markdown-syntax/</url><categories><category>themes</category><category>syntax</category></categories><tags><tag>markdown</tag><tag>css</tag><tag>html</tag></tags><content type="html"> 本文提供了一个可以在 Hugo 内容文件中使用的基本Markdown语法示例，还展示了基本 HTML 元素在 Hugo 主题中是否使用 CSS 装饰。
标题 下面的 HTML 代码&lt;h1>—&lt;h6> 元素表示六个级别的节标题。 &lt;h1>是最高的节级别，&lt;h6>是最低的节级别。
H1 H2 H3 H4 H5 H6 段落 Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.
伊塔图？厨房里有很多东西，我不知道他们喜欢吃什么，或者他们喜欢吃什么。
引用 blockquote元素表示从另一个来源引用的内容，可选的引用必须在footer或cite元素内，也可选的内嵌更改，如注释和缩写。
引用没有归属 Tiam, ad mint andaepu dandae nostion secatur sequo quae. 注意 可以在块引用中使用 Markdown 语法。
带归属的引用 不要通过分享记忆来交流，通过交流来分享记忆。
— 罗布·派克1
表格 表不是Markdown核心规范的一部分，但是Hugo支持开箱即用。
Name Age Bob 27 Alice 23 表格内使用Markdown语法 Italics Bold Code italics bold code 图像 ![图像描述](图像地址) 示例 Google Chrome Firefox Browser
点击图像可以打开图像浏览器，快试试吧。
代码块 带有引号的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 用四个空格缩进的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 代码块引用Hugo的内部高亮短代码 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 列表类型 有序列表 First item Second item Third item 无序列表 List item Another item And another item 嵌套列表 Fruit Apple Orange Banana Dairy Milk Cheese 其他元素 — abbr, sub, sup, kbd, mark GIF 是位图图像格式。
H2O
Xn + Yn = Zn
按 CTRL+ALT+Delete 组合键结束会话。
大多数蝾螈在夜间活动，捕食昆虫、蠕虫和其他小动物。
以上引文摘自Rob Pike在2015年11月18日Gopherfest上的演讲。&#160;&#8617;&#xfe0e;</content></entry><entry><title>富文本内容测试</title><url>https://lizj3624.github.io/post/rich-content/</url><categories/><tags><tag>shortcodes</tag><tag>privacy</tag></tags><content type="html"> Hugo上有几个内置短代码，用于丰富内容，以及隐私配置还有一组简单的短代码，支持各种社交媒体嵌入的静态和非JS版本。
YouTube Privacy Enhanced Shortcode Twitter Simple Shortcode .twitter-tweet { font: 14px/1.45 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif; border-left: 4px solid #2b7bb9; padding-left: 1.5em; color: #555; } .twitter-tweet a { color: #2b7bb9; text-decoration: none; } blockquote.twitter-tweet a:hover, blockquote.twitter-tweet a:focus { text-decoration: underline; } Vimeo Simple Shortcode .__h_video { position: relative; padding-bottom: 56.23%; height: 0; overflow: hidden; width: 100%; background: #000; } .__h_video img { width: 100%; height: auto; color: #000; } .__h_video .play { height: 72px; width: 72px; left: 50%; top: 50%; margin-left: -36px; margin-top: -36px; position: absolute; cursor: pointer; }</content></entry><entry><title>占位符文本显示</title><url>https://lizj3624.github.io/post/placeholder-text/</url><categories/><tags><tag>markdown</tag><tag>text</tag></tags><content type="html"> 你对我的心有偏见。我向您保证，我们的生活将不会受到影响，我们的生活将会受到影响。你说你现在住在医院里，因为你的眼睛是透明的，你的眼睛是光明的，你的眼睛是光明的!
Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.
Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt
The Van de Graaf Canon
Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.
Iubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.
Eurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.</content></entry><entry><title>数据公式设置显示</title><url>https://lizj3624.github.io/post/math-typesetting/</url><categories/><tags/><content type="html"> Hugo项目中的数学表示法可以通过使用第三方JavaScript库来实现。
在这个例子中，我们将使用 MathJax
Create a post under /content/en[zh-CN]/math.md
可以全局启用MathJax，请在项目配置中将参数math设置为true
或是在每页基础上启用MathJax，在内容文件中包括参数math: true
注意： 使用支持的TeX功能的联机参考资料
例子 重复的分数 $$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} \equiv 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } } $$
总和记号 $$ \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right) $$
几何级数之和 我把接下来的两个例子分成了几行，这样它在手机上表现得更好。这就是为什么它们包含 \displaystyle。
$$ \displaystyle\sum_{i=1}^{k+1}i $$
$$ \displaystyle= \left(\sum_{i=1}^{k}i\right) +(k+1) $$
$$ \displaystyle= \frac{k(k+1)}{2}+k+1 $$
$$ \displaystyle= \frac{k(k+1)+2(k+1)}{2} $$
$$ \displaystyle= \frac{(k+1)(k+2)}{2} $$
$$ \displaystyle= \frac{(k+1)((k+1)+1)}{2} $$
乘记号 $$ \displaystyle 1 + \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \displaystyle \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \displaystyle\text{ for }\lvert q\rvert &lt; 1. $$
随文数式 这是一些线性数学: $$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $$ ， 然后是更多的文本。
希腊字母 $$ \Gamma\ \Delta\ \Theta\ \Lambda\ \Xi\ \Pi\ \Sigma\ \Upsilon\ \Phi\ \Psi\ \Omega \alpha\ \beta\ \gamma\ \delta\ \epsilon\ \zeta\ \eta\ \theta\ \iota\ \kappa\ \lambda\ \mu\ \nu\ \xi \ \omicron\ \pi\ \rho\ \sigma\ \tau\ \upsilon\ \phi\ \chi\ \psi\ \omega\ \varepsilon\ \vartheta\ \varpi\ \varrho\ \varsigma\ \varphi $$
箭头 $$ \gets\ \to\ \leftarrow\ \rightarrow\ \uparrow\ \Uparrow\ \downarrow\ \Downarrow\ \updownarrow\ \Updownarrow $$
$$ \Leftarrow\ \Rightarrow\ \leftrightarrow\ \Leftrightarrow\ \mapsto\ \hookleftarrow \leftharpoonup\ \leftharpoondown\ \rightleftharpoons\ \longleftarrow\ \Longleftarrow\ \longrightarrow $$
$$ \Longrightarrow\ \longleftrightarrow\ \Longleftrightarrow\ \longmapsto\ \hookrightarrow\ \rightharpoonup $$
$$ \rightharpoondown\ \leadsto\ \nearrow\ \searrow\ \swarrow\ \nwarrow $$
符号 $$ \surd\ \barwedge\ \veebar\ \odot\ \oplus\ \otimes\ \oslash\ \circledcirc\ \boxdot\ \bigtriangleup $$
$$ \bigtriangledown\ \dagger\ \diamond\ \star\ \triangleleft\ \triangleright\ \angle\ \infty\ \prime\ \triangle $$
微积分学 $$ \int u \frac{dv}{dx},dx=uv-\int \frac{du}{dx}v,dx $$
$$ f(x) = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} $$
$$ \oint \vec{F} \cdot d\vec{s}=0 $$
洛伦茨方程 $$ \begin{aligned} \dot{x} &amp; = \sigma(y-x) \ \dot{y} &amp; = \rho x - y - xz \ \dot{z} &amp; = -\beta z + xy \end{aligned} $$
交叉乘积 这在KaTeX中是可行的，但在这种环境中馏分的分离不是很好。
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
这里有一个解决方案:使用“mfrac”类(在MathJax情况下没有区别)的额外类使分数更小:
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
强调 $$ \hat{x}\ \vec{x}\ \ddot{x} $$
有弹性的括号 $$ \left(\frac{x^2}{y^3}\right) $$
评估范围 $$ \left.\frac{x^3}{3}\right|_0^1 $$
诊断标准 $$ f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if } n\text{ is even} \ 3n+1, &amp; \text{if } n\text{ is odd} \end{cases} $$
麦克斯韦方程组 $$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \ \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \ \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \ \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
这些方程式很狭窄。我们可以使用(例如)添加垂直间距 [1em] 在每个换行符(\)之后。正如你在这里看到的：
$$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \[1em] \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \[0.5em] \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \[1em] \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
统计学 固定词组：
$$ \frac{n!}{k!(n-k)!} = {^n}C_k {n \choose k} $$
分数在分数 $$ \frac{\frac{1}{x}+\frac{1}{y}}{y-z} $$
ｎ次方根 $$ \sqrt[n]{1+x+x^2+x^3+\ldots} $$
矩阵 $$ \begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13}\ a_{21} &amp; a_{22} &amp; a_{23}\ a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix} \begin{bmatrix} 0 &amp; \cdots &amp; 0 \ \vdots &amp; \ddots &amp; \vdots \ 0 &amp; \cdots &amp; 0 \end{bmatrix} $$
标点符号 $$ f(x) = \sqrt{1+x} \quad (x \ge -1) f(x) \sim x^2 \quad (x\to\infty) $$
现在用标点符号:
$$ f(x) = \sqrt{1+x}, \quad x \ge -1 f(x) \sim x^2, \quad x\to\infty $$</content></entry><entry><title>支持Emoji表情符号</title><url>https://lizj3624.github.io/post/emoji-support/</url><categories/><tags><tag>emoji</tag></tags><content type="html"> 在Hugo项目中可以通过多种方式启用Emoji。
The emojify function can be called directly in templates or Inline Shortcodes.
To enable emoji globally, set enableEmoji to true in your site&rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.
馃檲 🙈 馃檳 🙉 馃檴 🙊
The Emoji cheat sheet is a useful reference for emoji shorthand codes.
N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.
.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }</content></entry><entry><title>关于我</title><url>https://lizj3624.github.io/about.html</url><categories/><tags/><content type="html"> Hugo是用Go编写的一个开放源代码静态站点生成器，可在Apache许可证2.0下使用。 Hugo支持TOML, YAML和JSON数据文件类型，Markdown和HTML内容文件，并使用短代码添加丰富的内容。其他值得注意的功能包括分类法、多语言模式、图像处理、自定义输出格式、HTML/CSS/JS缩小和对Sass SCSS工作流的支持。
Hugo使用了多种开源项目，包括:
https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo是博客、企业网站、创意作品集、在线杂志、单页应用程序甚至是数千页的网站的理想选择。
Hugo适合那些想要手工编写自己的网站代码，而不用担心设置复杂的运行时、依赖关系和数据库的人。
使用Hugo建立的网站非常快速、安全，可以部署在任何地方，包括AWS、GitHub Pages、Heroku、Netlify和任何其他托管提供商。
更多信息请访问GitHub.</content></entry></search>